# vim:ft=bash

# Stop shortening the directory once its length is no greater than this. The value can be either
# absolute (e.g., '50') or a percentage of terminal width (e.g, '50%').
#
# Currently only applied when POWERLEVEL9K_SHORTEN_STRATEGY=truncate_to_unique. If you want to use
# it with another shortening strategy, open an issue.

# Individual elements are patterns. They are expanded with the options set
# by `emulate zsh && setopt extended_glob`.

_p9k_shorten_delim_len() {
  local def=$1
  _P9K_RETVAL=${POWERLEVEL9K_SHORTEN_DELIMITER_LENGTH:--1}
  (( _P9K_RETVAL >= 0 )) || _p9k_prompt_length $1
}

################################################################
# Dir: current working directory
prompt_dir() {
  emulate -L zsh && setopt extended_glob

  [[ $POWERLEVEL9K_DIR_PATH_ABSOLUTE == true ]] && local p=$PWD || local p=${(%):-%~}

  if [[ $p == '~['* ]]; then
    # If "${(%):-%~}" expands to "~[a]/]/b", is the first component "~[a]" or "~[a]/]"?
    # One would expect "${(%):-%-1~}" to give the right answer but alas it always simply
    # gives the segment before the first slash, which would be "~[a]" in this case. Worse,
    # for "~[a/b]" it'll give the nonsensical "~a[". To solve this problem we have to
    # repeat what "${(%):-%~}" does and hope that it produces the same result.
    local func=''
    local -a parts=()
    for func in zsh_directory_name $zsh_directory_name_functions; do
      if (( $+functions[$func] )) && $func d $PWD && [[ $p == '~['$reply[1]']'* ]]; then
        parts+='~['$reply[1]']'
        break
      fi
    done
    if (( $#parts )); then
      parts+=(${(s:/:)${p#$parts[1]}})
    else
      p=$PWD
      parts=("${(s:/:)p}")
    fi
  else
    local -a parts=("${(s:/:)p}")
  fi

  local -i fake_first=0
  local delim=${POWERLEVEL9K_SHORTEN_DELIMITER-$'\u2026'}
  local -i shortenlen=${POWERLEVEL9K_SHORTEN_DIR_LENGTH:--1}

  case $POWERLEVEL9K_SHORTEN_STRATEGY in
    truncate_absolute|truncate_absolute_chars)
      if (( shortenlen > 0 && $#p > shortenlen )); then
        _p9k_shorten_delim_len $delim
        if (( $#p > shortenlen + $_P9K_RETVAL )); then
          local -i n=shortenlen
          local -i i=$#parts
          while true; do
            local dir=$parts[i]
            local -i len=$(( $#dir + (i > 1) ))
            if (( len <= n )); then
              (( n -= len ))
              (( --i ))
            else
              parts[i]=$'\0'$dir[-n,-1]
              parts[1,i-1]=()
              break
            fi
          done
        fi
      fi
    ;;
    truncate_with_package_name|truncate_middle|truncate_from_right)
      () {
        [[ $POWERLEVEL9K_SHORTEN_STRATEGY == truncate_with_package_name &&
           $+commands[jq] == 1 && $#POWERLEVEL9K_DIR_PACKAGE_FILES > 0 ]] || return
        local pat="(${(j:|:)POWERLEVEL9K_DIR_PACKAGE_FILES})"
        local -i i=$#parts
        local dir=$PWD
        for (( ; i > 0; --i )); do
          local pkg_file=''
          for pkg_file in $dir/${~pat}(N); do
            local -H stat=()
            zstat -H stat -- $pkg_file 2>/dev/null || return
            if ! _p9k_cache_get $0_pkg $stat[inode] $stat[mtime] $stat[size]; then
              local pkg_name=''
              pkg_name=$(command jq -j '.name' <$pkg_file 2>/dev/null) || pkg_name=''
              _p9k_cache_set "$pkg_name"
            fi
            [[ -n $_P9K_CACHE_VAL[1] ]] || return
            parts[1,i]=($_P9K_CACHE_VAL[1])
            fake_first=1
            return
          done
          dir=${dir:h}
        done
      }
      if (( shortenlen > 0 )); then
        _p9k_shorten_delim_len $delim
        local -i d=_P9K_RETVAL pref=shortenlen suf=0 i=2
        [[ $POWERLEVEL9K_SHORTEN_STRATEGY == truncate_middle ]] && suf=pref
        for (( ; i < $#parts; ++i )); do
          local dir=$parts[i]
          if (( $#dir > pref + suf + d )); then
            dir[pref+1,-suf-1]=$'\0'
            parts[i]=$dir
          fi
        done
      fi
    ;;
    truncate_to_last)
      fake_first=$(($#parts > 1))
      parts[1,-2]=()
    ;;
    truncate_to_first_and_last)
      if (( shortenlen > 0 )); then
        local -i i=$(( shortenlen + 1 ))
        [[ $p == /* ]] && (( ++i ))
        for (( ; i <= $#parts - shortenlen; ++i )); do
          parts[i]=$'\0'
        done
      fi
    ;;
    truncate_to_unique)
      local -i i=2 n=1
      [[ $p == /* ]] && (( ++i ))
      delim=${POWERLEVEL9K_SHORTEN_DELIMITER-'*'}
      _p9k_prompt_length $delim
      local -i real_delim_len=_P9K_RETVAL
      local -i d=${POWERLEVEL9K_SHORTEN_DELIMITER_LENGTH:--1}
      (( d >= 0 )) || d=real_delim_len
      shortenlen=${POWERLEVEL9K_SHORTEN_DIR_LENGTH:-1}
      (( shortenlen >= 0 )) && n=shortenlen
      if [[ $POWERLEVEL9K_DIR_MAX_LENGTH == *% ]]; then
        local -i max_len=$(( COLUMNS * $POWERLEVEL9K_DIR_MAX_LENGTH[1,-2] / 100 ))
      else
        local -i max_len=POWERLEVEL9K_DIR_MAX_LENGTH
      fi
      local -i len=$#p
      local parent="${PWD%/${(pj./.)parts[i,-1]}}"
      for (( ; len > max_len && i <= $#parts - n; ++i )); do
        local dir=$parts[i]
        if [[ -n $POWERLEVEL9K_SHORTEN_FOLDER_MARKER &&
              -n $parent/$dir/${~POWERLEVEL9K_SHORTEN_FOLDER_MARKER}(#qN) ]]; then
          parent+=/$dir
          continue
        fi
        local -i j=1
        for (( ; j + d < $#dir; ++j )); do
          local -a matching=($parent/$dir[1,j]*/(N))
          (( $#matching == 1 )) && break
        done
        if (( j + d < $#dir )); then
          (( len -= ($#dir - j - real_delim_len) ))
          parts[i]=$dir[1,j]$'\0'
        fi
        parent+=/$dir
      done
    ;;
    truncate_with_folder_marker)
      if [[ -n $POWERLEVEL9K_SHORTEN_FOLDER_MARKER ]]; then
        local dir=$PWD
        local -a m=()
        local -i i=$(($#parts - 1))
        for (( ; i > 1; --i )); do
          dir=${dir:h}
          [[ -n $dir/${~POWERLEVEL9K_SHORTEN_FOLDER_MARKER}(#qN) ]] && m+=$i
        done
        m+=1
        for (( i=1; i < $#m; ++i )); do
          (( m[i] - m[i+1] > 2 )) && parts[m[i+1]+1,m[i]-1]=($'\0')
        done
      fi
    ;;
    *)
      if (( shortenlen > 0 )); then
        local -i len=$#parts
        [[ -z $parts[1] ]] && (( --len ))
        if (( len > shortenlen )); then
          parts[1,-shortenlen-1]=($'\0')
        fi
      fi
    ;;
  esac

  [[ $POWERLEVEL9K_DIR_SHOW_WRITABLE == true && ! -w $PWD ]]
  local w=$?
  if ! _p9k_cache_get $0 $w $fake_first "$delim" "${parts[@]}"; then
    local state='' icon=''
    if (( ! w )); then
      state=NOT_WRITABLE
      icon=LOCK_ICON
    else
      case $PWD in
        /etc|/etc/*) state=ETC;            icon=ETC_ICON;;
        ~)           state=HOME;           icon=HOME_ICON;;
        ~/*)         state=HOME_SUBFOLDER; icon=HOME_SUB_ICON;;
        *)           state=DEFAULT;        icon=FOLDER_ICON;;
      esac
    fi

    local style=%b
    _p9k_color blue $0_$state BACKGROUND
    _p9k_background $_P9K_RETVAL
    style+=$_P9K_RETVAL
    _p9k_color "$DEFAULT_COLOR" "$0_$state" FOREGROUND
    _p9k_foreground $_P9K_RETVAL
    style+=$_P9K_RETVAL

    parts=("${(@)parts//\%/%%}")
    [[ $fake_first == 0 && $parts[1] == '~' ]] && parts[1]=$POWERLEVEL9K_HOME_FOLDER_ABBREVIATION$style
    [[ $POWERLEVEL9K_DIR_OMIT_FIRST_CHARACTER == true && $#parts > 1 && -n $parts[2] ]] && parts[1]=()

    local last_fg=
    [[ $POWERLEVEL9K_DIR_PATH_HIGHLIGHT_BOLD == true ]] && last_fg+=%B
    if [[ -n $POWERLEVEL9K_DIR_PATH_HIGHLIGHT_FOREGROUND ]]; then
      _p9k_translate_color $POWERLEVEL9K_DIR_PATH_HIGHLIGHT_FOREGROUND
      _p9k_foreground $_P9K_RETVAL
      last_fg+=$_P9K_RETVAL
    fi
    parts[-1]=$last_fg${parts[-1]//$'\0'/$'\0'$last_fg}$style
    parts=("${(@)parts//$'\0'/$delim$style}")

    local sep=$POWERLEVEL9K_DIR_PATH_SEPARATOR$style
    if [[ -n $POWERLEVEL9K_DIR_PATH_SEPARATOR_FOREGROUND ]]; then
      _p9k_translate_color $POWERLEVEL9K_DIR_PATH_SEPARATOR_FOREGROUND
      _p9k_foreground $_P9K_RETVAL
      sep=$_P9K_RETVAL$sep
    fi

    _p9k_cache_set "$0_$state" "$2" blue "$DEFAULT_COLOR" "$icon" 0 "" "${(pj.$sep.)parts}"
  fi
  "$1_prompt_segment" "$_P9K_CACHE_VAL[@]"
}
