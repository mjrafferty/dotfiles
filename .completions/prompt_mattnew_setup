# vim:ft=bash

_p9k_installation_dir="$HOME/.completions"

source "${_p9k_installation_dir}/functions/defaults.zsh"
source "${_p9k_installation_dir}/functions/utilities.zsh"
source "${_p9k_installation_dir}/functions/icons.zsh"
source "${_p9k_installation_dir}/functions/colors.zsh"
source "${_p9k_installation_dir}/functions/vcs.zsh"

typeset -g _P9K_RETVAL
typeset -g _P9K_CACHE_KEY
typeset -ga _P9K_CACHE_VAL
typeset -gA _P9K_CACHE
typeset -ga _P9K_T
typeset -g _P9K_N
typeset -gi _P9K_I
typeset -g _P9K_BG
typeset -g _P9K_F
typeset -ga _P9K_LEFT_JOIN=(1)
typeset -ga _P9K_RIGHT_JOIN=(1)
typeset -g _P9K_XY _P9K_ALIGNED_RPROMPT
typeset -gi _P9K_X _P9K_Y _P9K_M _P9K_RPROMPT_DONE _P9K_IND
typeset -gF _P9K_TIMER_START
typeset -g _P9K_PROMPT
typeset -g _P9K_RPROMPT
typeset -g _P9K_LEFT_PREFIX
typeset -g _P9K_LEFT_SUFFIX
typeset -g _P9K_RIGHT_PREFIX
typeset -g _P9K_RIGHT_SUFFIX
typeset -g _P9K_REFRESH_REASON
typeset -gi _P9K_REGION_ACTIVE
typeset -g DEFAULT_COLOR
typeset -g DEFAULT_COLOR_INVERTED
typeset -gi _P9K_INITIALIZED=0
typeset -g OS
typeset -g OS_ICON
typeset -g SED_EXTENDED_REGEX_PARAMETER
typeset -g  _P9K_TIMER_FIFO
typeset -gi _P9K_TIMER_FD=0
typeset -gi _P9K_TIMER_PID=0
typeset -gi _P9K_TIMER_SUBSHELL=0
typeset -gi _P9K_ENABLED=0

## Caching Section ##

# Specifies the maximum number of elements in the cache. When the cache grows over this limit,
# it gets cleared. This is meant to avoid memory leaks when a rogue prompt is filling the cache
# with data.

# Caching allows storing array-to-array associations. It should be used like this:
#
#   if ! _p9k_cache_get "$key1" "$key2"; then
#     # Compute val1 and val2 and then store them in the cache.
#     _p9k_cache_set "$val1" "$val2"
#   fi
#   # Here ${_P9K_CACHE_VAL[1]} and ${_P9K_CACHE_VAL[2]} are $val1 and $val2 respectively.
#
# Limitations:
#
#   * Calling _p9k_cache_set without arguments clears the cache entry. Subsequent calls to
#     _p9k_cache_get for the same key will return an error.
#   * There must be no intervening _p9k_cache_get calls between the associated _p9k_cache_get
#     and _p9k_cache_set.
_p9k_cache_set() {
  # Uncomment to see cache misses.
  # echo "caching: ${(@0q)_P9K_CACHE_KEY} => (${(q)@})" >&2
  _P9K_CACHE[$_P9K_CACHE_KEY]="${(pj:\0:)*}0"
  _P9K_CACHE_VAL=("$@")
  (( $#_P9K_CACHE < POWERLEVEL9K_MAX_CACHE_SIZE )) || typeset -gAH _P9K_CACHE=()
}

_p9k_cache_get() {
  _P9K_CACHE_KEY="${(pj:\0:)*}"
  local v=$_P9K_CACHE[$_P9K_CACHE_KEY]
  [[ -n $v ]] && _P9K_CACHE_VAL=("${(@0)${v[1,-2]}}")
}

_p9k_cached_cmd_stdout() {
  local cmd=$commands[$1]
  [[ -n $cmd ]] || return
  shift
  local -H stat
  zstat -H stat -- $cmd 2>/dev/null || return
  if ! _p9k_cache_get $0 $stat[inode] $stat[mtime] $stat[size] $stat[mode] $cmd "$@"; then
    local out
    out=$($cmd "$@" 2>/dev/null)
    _p9k_cache_set $(( ! $? )) "$out"
  fi
  (( $_P9K_CACHE_VAL[1] )) || return
  _P9K_RETVAL=$_P9K_CACHE_VAL[2]
}

_p9k_cached_cmd_stdout_stderr() {
  local cmd=$commands[$1]
  [[ -n $cmd ]] || return
  shift
  local -H stat
  zstat -H stat -- $cmd 2>/dev/null || return
  if ! _p9k_cache_get $0 $stat[inode] $stat[mtime] $stat[size] $stat[mode] $cmd "$@"; then
    local out
    out=$($cmd "$@" 2>&1)  # this line is the only diff with _p9k_cached_cmd_stdout
    _p9k_cache_set $(( ! $? )) "$out"
  fi
  (( $_P9K_CACHE_VAL[1] )) || return
  _P9K_RETVAL=$_P9K_CACHE_VAL[2]
}

## Caching Section ##

## Timer Section ##

_p9k_on_timer() {
  emulate -L zsh
  local dummy
  while IFS='' read -t -u $_P9K_TIMER_FD dummy; do true; done
  zle && zle .reset-prompt && zle -R
}

_p9k_kill_timer() {
  emulate -L zsh
  if (( ZSH_SUBSHELL == _P9K_TIMER_SUBSHELL )); then
    (( _P9K_TIMER_PID )) && kill -- -$_P9K_TIMER_PID &>/dev/null
    command rm -f $_P9K_TIMER_FIFO
  fi
}

_p9k_start_timer() {
  emulate -L zsh
  setopt err_return no_bg_nice

  _P9K_TIMER_FIFO=$(mktemp -u "${TMPDIR:-/tmp}"/p9k.$$.timer.pipe.XXXXXXXXXX)
  mkfifo $_P9K_TIMER_FIFO
  sysopen -rw -o cloexec,sync -u _P9K_TIMER_FD $_P9K_TIMER_FIFO
  zsystem flock $_P9K_TIMER_FIFO

  zle -F $_P9K_TIMER_FD _p9k_on_timer

  # `kill -WINCH $$` is a workaround for a bug in zsh. After a background job completes, callbacks
  # registered with `zle -F` stop firing until the user presses any key or the process receives a
  # signal (any signal at all).
  zsh -c "
  zmodload zsh/system
  while sleep 1 && ! zsystem flock -t 0 ${(q)_P9K_TIMER_FIFO} && kill -WINCH $$ && echo; do
    true
  done
  command rm -f ${(q)_P9K_TIMER_FIFO}
  " </dev/null >&$_P9K_TIMER_FD 2>/dev/null &!

  _P9K_TIMER_PID=$!
  _P9K_TIMER_SUBSHELL=$ZSH_SUBSHELL

  add-zsh-hook zshexit _p9k_kill_timer
}

_p9k_init_timer() {

  if ! _p9k_start_timer ; then
    echo "powerlevel10k: failed to initialize background timer" >&2
    if (( _P9K_TIMER_FD )); then
      zle -F $_P9K_TIMER_FD
      exec {_P9K_TIMER_FD}>&-
      _P9K_TIMER_FD=0
    fi
    if (( _P9K_TIMER_PID )); then
      kill -- -$_P9K_TIMER_PID &>/dev/null
      _P9K_TIMER_PID=0
    fi
    command rm -f $_P9K_TIMER_FIFO
    _P9K_TIMER_FIFO=''
    unset -f _p9k_on_timer
  fi
}

## Timer Section ##

# Sets _P9K_RETVAL to the icon whose name is supplied via $1.
_p9k_get_icon() {
  local var_name=POWERLEVEL9K_$1
  _P9K_RETVAL=${(g::)${${(P)var_name}-$icons[$1]}}
  [[ $_P9K_RETVAL != $'\b'? ]] || _P9K_RETVAL="%{$_P9K_RETVAL%}"  # penance for past sins
}

_p9k_translate_color() {
  if [[ $1 == '<->' ]]; then     # decimal color code: 255
    _P9K_RETVAL=$1
  elif [[ $1 == '#'* ]]; then  # hexademical color code: #ffffff
    _P9K_RETVAL=$1
  else                         # named color: red
    # Strip prifixes if there are any.
    _P9K_RETVAL=$__P9K_COLORS[${${${1#bg-}#fg-}#br}]
  fi
}

# Resolves a color to its numerical value, or an empty string. Communicates the result back
# by setting _P9K_RETVAL.
_p9k_color() {
  local user_var=POWERLEVEL9K_${(U)${2}#prompt_}_${3}
  _p9k_translate_color ${${(P)user_var}:-${1}}
}

_p9k_background() {
  [[ -n $1 ]] && _P9K_RETVAL="%K{$1}" || _P9K_RETVAL="%k"
}

_p9k_foreground() {
  [[ -n $1 ]] && _P9K_RETVAL="%F{$1}" || _P9K_RETVAL="%f"
}

_p9k_escape_rcurly() {
  _P9K_RETVAL=${${1//\\/\\\\}//\}/\\\}}
}

# Begin a left prompt segment.
#
#    * $1: Name of the function that was originally invoked.
#          Necessary, to make the dynamic color-overwrite mechanism work.
#    * $2: The array index of the current segment.
#    * $3: Background color.
#    * $4: Foreground color.
#    * $5: An identifying icon (must be a key of the icons array).
#    * $6: 1 to to perform parameter expansion and process substitution.
#    * $7: If not empty but becomes empty after parameter expansion and process substitution,
#          the segment isn't rendered.
#   * $8+: The segment content
left_prompt_segment() {
  if ! _p9k_cache_get "$0" "$1" "$2" "$3" "$4" "$5"; then
    _p9k_color $3 $1 BACKGROUND
    local bg_color=$_P9K_RETVAL
    _p9k_background $bg_color
    local bg=$_P9K_RETVAL

    _p9k_color $4 $1 FOREGROUND
    local fg_color=$_P9K_RETVAL
    _p9k_foreground $fg_color
    local fg=$_P9K_RETVAL

    _p9k_get_icon LEFT_SUBSEGMENT_SEPARATOR
    local subsep=$_P9K_RETVAL

    _p9k_escape_rcurly $POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS
    local space=$_P9K_RETVAL

    local icon
    local -i has_icon
    if [[ -n $5 ]]; then
      _p9k_get_icon $5
      if [[ -n $_P9K_RETVAL ]]; then
        local glyph=$_P9K_RETVAL
        _p9k_color $fg_color $1 VISUAL_IDENTIFIER_COLOR
        _p9k_foreground $_P9K_RETVAL
        icon=$_P9K_RETVAL$glyph
        has_icon=1
      fi
    fi

    # Segment separator logic:
    #
    #   if [[ $_P9K_BG == NONE ]]; then
    #     1
    #   elif (( joined )); then
    #     2
    #   elif [[ $bg_color == $_P9K_BG ]]; then
    #     3
    #   else
    #     4
    #   fi

    local t=$#_P9K_T
    _P9K_T+=$bg$POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS$icon                         # 1
    _P9K_T+=$bg$icon                                                                       # 2
    if [[ -z $fg_color ]]; then
      _p9k_foreground $DEFAULT_COLOR
      _P9K_T+=$bg$_P9K_RETVAL$subsep$POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS$icon    # 3
    else
      _P9K_T+=$bg$fg$subsep$POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS$icon             # 3
    fi
    _p9k_get_icon LEFT_SEGMENT_SEPARATOR
    _P9K_T+=$bg$_P9K_RETVAL$POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS$icon             # 4

    local pre
    pre+="\${_P9K_N::=}\${_P9K_F::=}"
    pre+="\${\${\${_P9K_BG:-0}:#NONE}:-\${_P9K_N::=$((t+1))}}"                        # 1
    pre+="\${_P9K_N:=\${\${\$((_P9K_I>=$_P9K_LEFT_JOIN[$2])):#0}:+$((t+2))}}"         # 2
    pre+="\${_P9K_N:=\${\${\$((!\${#\${:-0\$_P9K_BG}:#0$bg_color})):#0}:+$((t+3))}}"  # 3
    pre+="\${_P9K_N:=\${\${_P9K_F::=%F{\$_P9K_BG\}}+$((t+4))}}}+}"                    # 4
    pre+="%b\${_P9K_F}\${_P9K_T[\$_P9K_N]}"

    _p9k_escape_rcurly %b$bg$fg
    local post="\${_P9K_C}$_P9K_RETVAL$space\${\${_P9K_I::=$2}+}\${\${_P9K_BG::=$bg_color}+}}"

    _p9k_cache_set $has_icon $_P9K_RETVAL $pre $post
  fi

  local name=$1
  local -i has_icon=${_P9K_CACHE_VAL[1]}
  local style=${_P9K_CACHE_VAL[2]}
  local -i expand=$6
  local cond=${7:-1}
  shift 7

    local content="${(j::):-$style${^@}}"
  (( expand )) || content="\${(Q)\${:-${(qqq)content}}}"

  _P9K_PROMPT+="\${\${:-$cond}:+\${\${:-\${_P9K_C::=${content}}${_P9K_CACHE_VAL[3]}"
  (( has_icon )) && _P9K_PROMPT+='${${(%):-$_P9K_C%1(l. .x)}[-1]%x}'
  _P9K_PROMPT+=${_P9K_CACHE_VAL[4]}
}

# The same as left_prompt_segment above but for the right prompt.
right_prompt_segment() {
  if ! _p9k_cache_get "$0" "$1" "$2" "$3" "$4" "$5"; then
    _p9k_color $3 $1 BACKGROUND
    local bg_color=$_P9K_RETVAL
    _p9k_background $bg_color
    local bg=$_P9K_RETVAL

    _p9k_color $4 $1 FOREGROUND
    local fg_color=$_P9K_RETVAL
    _p9k_foreground $fg_color
    local fg=$_P9K_RETVAL

    _p9k_get_icon RIGHT_SUBSEGMENT_SEPARATOR
    local subsep=$_P9K_RETVAL

    local icon_style icon
    local -i has_icon
    if [[ -n $5 ]]; then
      _p9k_get_icon $5
      if [[ -n $_P9K_RETVAL ]]; then
        _p9k_escape_rcurly $_P9K_RETVAL
        icon=$_P9K_RETVAL
        _p9k_color $fg_color $1 VISUAL_IDENTIFIER_COLOR
        _p9k_foreground $_P9K_RETVAL
        _p9k_escape_rcurly %b$bg$_P9K_RETVAL
        icon_style=$_P9K_RETVAL
        has_icon=1
      fi
    fi

    # Segment separator logic is the same as in left_prompt_segment except that here #4 and #1 are
    # identical.

    local t=$#_P9K_T
    _p9k_get_icon RIGHT_SEGMENT_SEPARATOR
    _P9K_T+="%F{$bg_color}$_P9K_RETVAL$bg$POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS$fg"  # 1
    _P9K_T+=$fg                                                                               # 2
    if [[ -z $fg_color ]]; then
      _p9k_foreground $DEFAULT_COLOR
      _P9K_T+=$bg$_P9K_RETVAL$subsep$POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS$fg        # 3
    else
      _P9K_T+=$bg$fg$subsep$POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS                    # 3
    fi

    local pre
    pre+="\${_P9K_N::=}"
    pre+="\${\${\${_P9K_BG:-0}:#NONE}:-\${_P9K_N::=$((t+1))}}"                        # 1
    pre+="\${_P9K_N:=\${\${\$((_P9K_I>=$_P9K_RIGHT_JOIN[$2])):#0}:+$((t+2))}}"        # 2
    pre+="\${_P9K_N:=\${\${\$((!\${#\${:-0\$_P9K_BG}:#0$bg_color})):#0}:+$((t+3))}}"  # 3
    pre+="\${_P9K_N:=$((t+1))}}+}"                                                    # 4 == 1
    pre+="\${_P9K_T[\$_P9K_N]}\${_P9K_C}$icon_style"

    _p9k_escape_rcurly $POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS
    local space=$_P9K_RETVAL
    _p9k_escape_rcurly %b$bg$fg
    local post="$icon$_P9K_RETVAL$space\${\${_P9K_I::=$2}+}\${\${_P9K_BG::=$bg_color}+}}"

    _p9k_cache_set $has_icon $_P9K_RETVAL $pre $post
  fi

  local -i has_icon=${_P9K_CACHE_VAL[1]}
  local style=${_P9K_CACHE_VAL[2]}
  local -i expand=$6
  local cond=${7:-1}
  shift 7

  _p9k_escape_rcurly $style
  local content="${(j::):-$_P9K_RETVAL${^@}}"
  (( expand )) || content="\${(Q)\${:-${(qqq)content}}}"

  _P9K_PROMPT+="\${\${:-$cond}:+\${\${:-\${_P9K_C::=${content}}${_P9K_CACHE_VAL[3]}"
  (( has_icon )) && _P9K_PROMPT+='${${(%):-$_P9K_C%1(l. .x)}[-1]%x}'
  _P9K_PROMPT+=${_P9K_CACHE_VAL[4]}
}

# Returns 1 if the cursor is at the very end of the screen.
_p9k_left_prompt_end_line() {
  _p9k_get_icon LEFT_SEGMENT_SEPARATOR
  _p9k_escape_rcurly $_P9K_RETVAL
  _P9K_PROMPT+="%k%b"
  _P9K_PROMPT+="\${_P9K_N::=}"
  _P9K_PROMPT+="\${\${\${_P9K_BG:#NONE}:-\${_P9K_N:=1}}+}"
  _P9K_PROMPT+="\${\${_P9K_N:=2}+}"
  _P9K_PROMPT+="\${\${_P9K_T[2]::=%F{\$_P9K_BG\}$_P9K_RETVAL}+}"
  _P9K_PROMPT+="\${_P9K_T[\$_P9K_N]}"
  _P9K_PROMPT+="%f$1%f%k%b"

  if (( ! _P9K_RPROMPT_DONE )); then
    _P9K_PROMPT+=$_P9K_ALIGNED_RPROMPT
    _P9K_RPROMPT_DONE=1
    return 1
  fi
}

################################################################
# The 'custom` prompt provides a way for users to invoke commands and display
# the output in a segment.
prompt_custom() {
  local segment_name="${3:u}"
  # Get content of custom segment
  local command="POWERLEVEL9K_CUSTOM_${segment_name}"
  local -a cmd=("${(@Q)${(z)${(P):-POWERLEVEL9K_CUSTOM_${segment_name}}}}")
  whence $cmd[1] &>/dev/null || return
  local content=$("$cmd[@]")
  [[ -n $content ]] || return
  "$1_prompt_segment" "${0}_${3:u}" "$2" $DEFAULT_COLOR_INVERTED $DEFAULT_COLOR "CUSTOM_${segment_name}_ICON" 0 '' "$content"
}

################################################################
# Show a ratio of tests vs code
build_test_stats() {
  local code_amount="$4"
  local tests_amount="$5"
  local headline="$6"

  (( code_amount > 0 )) || return
  local -F 2 ratio=$(( 100. * tests_amount / code_amount ))

  (( ratio >= 75 )) && "$1_prompt_segment" "${2}_GOOD" "$3" "cyan" "$DEFAULT_COLOR" "$6" 0 '' "$headline: $ratio%%"
  (( ratio >= 50 && ratio < 75 )) && "$1_prompt_segment" "$2_AVG" "$3" "yellow" "$DEFAULT_COLOR" "$6" 0 '' "$headline: $ratio%%"
  (( ratio < 50 )) && "$1_prompt_segment" "$2_BAD" "$3" "red" "$DEFAULT_COLOR" "$6" 0 '' "$headline: $ratio%%"
}

################################################################
# Prompt processing and drawing
################################################################
# Main prompt

# Returns 1 if the cursor is at the very end of the screen.
build_left_prompt() {
  local -i index=1
  local element
  for element in "${POWERLEVEL9K_LEFT_PROMPT_ELEMENTS[@]}"; do
    # Remove joined information in direct calls
    element=${element%_joined}

    # Check if it is a custom command, otherwise interpet it as
    # a prompt.
    if [[ $element == custom_* ]]; then
      "prompt_custom" "left" "$index" $element[8,-1]
    else
      (( $+functions[prompt_$element] )) && "prompt_$element" "left" "$index"
    fi

    ((++index))
  done

  _p9k_get_icon LEFT_SEGMENT_END_SEPARATOR
  _p9k_left_prompt_end_line $_P9K_RETVAL
}

# Right prompt
build_right_prompt() {
  local -i index=1
  local element

  for element in "${POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS[@]}"; do
    # Remove joined information in direct calls
    element=${element%_joined}

    # Check if it is a custom command, otherwise interpet it as
    # a prompt.
    if [[ $element == custom_* ]]; then
      "prompt_custom" "right" "$index" $element[8,-1]
    else
      (( $+functions[prompt_$element] )) && "prompt_$element" "right" "$index"
    fi

    ((++index))
  done
}

powerlevel9k_preexec() {
  _P9K_TIMER_START=$EPOCHREALTIME
}

_p9k_set_prompt() {
  emulate -L zsh
  PROMPT=
  RPROMPT=
  if [[ $POWERLEVEL9K_DISABLE_RPROMPT == true ]]; then
    _P9K_RPROMPT_DONE=1
  else
    _P9K_PROMPT=
    build_right_prompt
    local right=$_P9K_RIGHT_PREFIX$_P9K_PROMPT$_P9K_RIGHT_SUFFIX
    if [[ $POWERLEVEL9K_PROMPT_ON_NEWLINE != true || $POWERLEVEL9K_RPROMPT_ON_NEWLINE == true ]]; then
      RPROMPT=$right
      _P9K_RPROMPT_DONE=1
    else
      unset _P9K_RPROMPT_OVERRIDE
      PROMPT="\${\${_P9K_RPROMPT::=\${_P9K_RPROMPT_OVERRIDE-$right}}+}"
      _P9K_RPROMPT_DONE=0
    fi
  fi

  _P9K_PROMPT=''
  if build_left_prompt; then
    PROMPT+=$_P9K_LEFT_PREFIX$_P9K_PROMPT$_P9K_LEFT_SUFFIX
  else
    PROMPT+=$_P9K_LEFT_PREFIX$_P9K_PROMPT${_P9K_LEFT_SUFFIX#$'\n'}
  fi
}

_p9k_update_prompt() {
  (( _P9K_ENABLED )) || return
  _P9K_REFRESH_REASON=$1
  _p9k_set_prompt
  _P9K_REFRESH_REASON=''
  zle && zle .reset-prompt && zle -R
}

powerlevel9k_refresh_prompt_inplace() {
  emulate -L zsh

  _p9k_init

  _P9K_REFRESH_REASON=precmd
  _p9k_set_prompt
  _P9K_REFRESH_REASON=''
}

powerlevel9k_prepare_prompts() {
  _P9K_EXIT_CODE=$?
  _P9K_PIPE_EXIT_CODES=( "$pipestatus[@]" )
  _P9K_COMMAND_DURATION=$((EPOCHREALTIME - _P9K_TIMER_START))
  _P9K_TIMER_START=1e10
  _P9K_REGION_ACTIVE=0

  unsetopt localoptions
  prompt_opts=(cr percent sp subst)
  setopt nopromptbang prompt{cr,percent,sp,subst}

  powerlevel9k_refresh_prompt_inplace
}

_p9k_zle_keymap_select() {
  zle && zle .reset-prompt && zle -R
}

# Does ZSH have a certain off-by-one bug that triggers when PROMPT overflows to a new line?
#
# Bug: https://github.com/zsh-users/zsh/commit/d8d9fee137a5aa2cf9bf8314b06895bfc2a05518.
# ZSH_PATCHLEVEL=zsh-5.4.2-159-gd8d9fee13. Released in 5.5.
#
# Fix: https://github.com/zsh-users/zsh/commit/64d13738357c9b9c212adbe17f271716abbcf6ea.
# ZSH_PATCHLEVEL=zsh-5.7.1-50-g64d137383.
#
# Test: PROMPT="${(pl:$((COLUMNS))::-:)}<%1(l.%2(l.FAIL.PASS).FAIL)> " zsh -dfis <<<exit
# Workaround: PROMPT="${(pl:$((COLUMNS))::-:)}%{%G%}<%1(l.%2(l.FAIL.PASS).FAIL)> " zsh -dfis <<<exit
_p9k_prompt_overflow_bug() {
  [[ $ZSH_PATCHLEVEL =~ '^zsh-5\.4\.2-([0-9]+)-' ]] && return $(( match[1] < 159 ))
  [[ $ZSH_PATCHLEVEL =~ '^zsh-5\.7\.1-([0-9]+)-' ]] && return $(( match[1] >= 50 ))
  is-at-least 5.5 && ! is-at-least 5.7.2
}

# Some people write POWERLEVEL9K_DIR_PATH_SEPARATOR='\uNNNN' instead of
# POWERLEVEL9K_DIR_PATH_SEPARATOR=$'\uNNNN'. There is no good reason for it and if we were
# starting from scratch we wouldn't perform automatic conversion from the former to the latter.
# But we aren't starting from scratch, so convert we do.
_p9k_init_strings() {
  # To find candidates:
  #
  #   egrep 'set_default [^-]' powerlevel9k.zsh-theme | egrep -v '(true|false)$'
  _p9k_g_expand POWERLEVEL9K_ANACONDA_LEFT_DELIMITER
  _p9k_g_expand POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER
  _p9k_g_expand POWERLEVEL9K_CONTEXT_TEMPLATE
  _p9k_g_expand POWERLEVEL9K_DATE_FORMAT
  _p9k_g_expand POWERLEVEL9K_DIR_PATH_SEPARATOR
  _p9k_g_expand POWERLEVEL9K_HOME_FOLDER_ABBREVIATION
  _p9k_g_expand POWERLEVEL9K_HOST_TEMPLATE
  _p9k_g_expand POWERLEVEL9K_SHORTEN_DELIMITER
  _p9k_g_expand POWERLEVEL9K_TIME_FORMAT
  _p9k_g_expand POWERLEVEL9K_USER_TEMPLATE
  _p9k_g_expand POWERLEVEL9K_VCS_LOADING_TEXT
  _p9k_g_expand POWERLEVEL9K_VI_COMMAND_MODE_STRING
  _p9k_g_expand POWERLEVEL9K_VI_INSERT_MODE_STRING
  _p9k_g_expand POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS
  _p9k_g_expand POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS
}

_p9k_init() {
  (( _P9K_INITIALIZED )) && return

  _p9k_init_icons
  _p9k_init_strings

  function _$0_set_os() {
    OS=$1
    _p9k_get_icon $2
    OS_ICON=$_P9K_RETVAL
  }

  trap "unfunction _$0_set_os" EXIT

  if [[ $(uname -o 2>/dev/null) == Android ]]; then
    _$0_set_os Android ANDROID_ICON
  else
    case $(uname) in
      SunOS)                     _$0_set_os Solaris SUNOS_ICON;;
      Darwin)                    _$0_set_os OSX     APPLE_ICON;;
      CYGWIN_NT-* | MSYS_NT-*)   _$0_set_os Windows WINDOWS_ICON;;
      FreeBSD|OpenBSD|DragonFly) _$0_set_os BSD     FREEBSD_ICON;;
      Linux)
        OS='Linux'
        local os_release_id
        [[ -f /etc/os-release &&
          "${(f)$((</etc/os-release) 2>/dev/null)}" =~ "ID=([A-Za-z]+)" ]] && os_release_id="${match[1]}"
        case "$os_release_id" in
          *arch*)                  _$0_set_os Linux LINUX_ARCH_ICON;;
          *debian*)                _$0_set_os Linux LINUX_DEBIAN_ICON;;
          *raspbian*)              _$0_set_os Linux LINUX_RASPBIAN_ICON;;
          *ubuntu*)                _$0_set_os Linux LINUX_UBUNTU_ICON;;
          *elementary*)            _$0_set_os Linux LINUX_ELEMENTARY_ICON;;
          *fedora*)                _$0_set_os Linux LINUX_FEDORA_ICON;;
          *coreos*)                _$0_set_os Linux LINUX_COREOS_ICON;;
          *gentoo*)                _$0_set_os Linux LINUX_GENTOO_ICON;;
          *mageia*)                _$0_set_os Linux LINUX_MAGEIA_ICON;;
          *centos*)                _$0_set_os Linux LINUX_CENTOS_ICON;;
          *opensuse*|*tumbleweed*) _$0_set_os Linux LINUX_OPENSUSE_ICON;;
          *sabayon*)               _$0_set_os Linux LINUX_SABAYON_ICON;;
          *slackware*)             _$0_set_os Linux LINUX_SLACKWARE_ICON;;
          *linuxmint*)             _$0_set_os Linux LINUX_MINT_ICON;;
          *alpine*)                _$0_set_os Linux LINUX_ALPINE_ICON;;
          *aosc*)                  _$0_set_os Linux LINUX_AOSC_ICON;;
          *nixos*)                 _$0_set_os Linux LINUX_NIXOS_ICON;;
          *devuan*)                _$0_set_os Linux LINUX_DEVUAN_ICON;;
          *manjaro*)               _$0_set_os Linux LINUX_MANJARO_ICON;;
          *)                       _$0_set_os Linux LINUX_ICON;;
        esac
        ;;
    esac
  fi

  if [[ $POWERLEVEL9K_COLOR_SCHEME == light ]]; then
    DEFAULT_COLOR=white
    DEFAULT_COLOR_INVERTED=black
  else
    DEFAULT_COLOR=black
    DEFAULT_COLOR_INVERTED=white
  fi

  local i
  for ((i = 2; i <= $#POWERLEVEL9K_LEFT_PROMPT_ELEMENTS; ++i)); do
    local elem=$POWERLEVEL9K_LEFT_PROMPT_ELEMENTS[$i]
    if [[ $elem == *_joined ]]; then
      _P9K_LEFT_JOIN+=$_P9K_LEFT_JOIN[((i-1))]
    else
      _P9K_LEFT_JOIN+=$i
    fi
  done

  for ((i = 2; i <= $#POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS; ++i)); do
    local elem=$POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS[$i]
    if [[ $elem == *_joined ]]; then
      _P9K_RIGHT_JOIN+=$_P9K_RIGHT_JOIN[((i-1))]
    else
      _P9K_RIGHT_JOIN+=$i
    fi
  done

  if [[ $POWERLEVEL9K_EXPERIMENTAL_TIME_REALTIME == true ]]; then
    _p9k_init_timer
  fi

  _P9K_ALIGNED_RPROMPT='${${:-${_P9K_X::=0}${_P9K_Y::=$((COLUMNS+1))}'
  repeat 10; do
    _P9K_ALIGNED_RPROMPT+='${_P9K_M::=$(((_P9K_X+_P9K_Y)/2))}'
    _P9K_ALIGNED_RPROMPT+='${_P9K_XY::=${${(%):-$_P9K_RPROMPT%$_P9K_M(l./$_P9K_M;$_P9K_Y./$_P9K_X;$_P9K_M)}##*/}}'
    _P9K_ALIGNED_RPROMPT+='${_P9K_X::=${_P9K_XY%;*}}'
    _P9K_ALIGNED_RPROMPT+='${_P9K_Y::=${_P9K_XY#*;}}'
  done
  _P9K_ALIGNED_RPROMPT+='${_P9K_X::=$((_P9K_X+2+_P9K_IND))}'
  _P9K_ALIGNED_RPROMPT+='${_P9K_Y::=$((_P9K_X+31))}}+}'

  repeat 32; do
    _P9K_ALIGNED_RPROMPT+='%-$_P9K_Y(l.                                .)'
  done
  repeat 32; do
    _P9K_ALIGNED_RPROMPT+='%-$_P9K_X(l. .)'
  done
  _P9K_ALIGNED_RPROMPT+=' $_P9K_RPROMPT'
  _P9K_ALIGNED_RPROMPT+='$_P9K_T[$((3+!_P9K_IND))]'

  _P9K_LEFT_PREFIX+='${${_P9K_IND::=${${ZLE_RPROMPT_INDENT:-1}/#-*/0}}+}'

  if [[ $POWERLEVEL9K_PROMPT_ADD_NEWLINE == true ]]; then
    repeat ${POWERLEVEL9K_PROMPT_ADD_NEWLINE_COUNT:-1} _P9K_LEFT_PREFIX+=$'\n'
  fi

  if [[ $POWERLEVEL9K_SHOW_RULER == true ]]; then
    _p9k_get_icon RULER_CHAR
    local ruler_char=$_P9K_RETVAL
    _p9k_prompt_length $ruler_char
    if (( _P9K_RETVAL == 1 && $#ruler_char == 1 )); then
      _p9k_color "" prompt_ruler BACKGROUND
      _p9k_background $_P9K_RETVAL
      _P9K_LEFT_PREFIX+=$_P9K_RETVAL
      _p9k_color "" prompt_ruler FOREGROUND
      _p9k_foreground $_P9K_RETVAL
      _P9K_LEFT_PREFIX+=$_P9K_RETVAL
      [[ $ruler_char == '.' ]] && local sep=',' || local sep='.'
      local ruler_len='${$((COLUMNS-_P9K_IND))/#-*/0}'
      _P9K_LEFT_PREFIX+="%b\${(pl$sep$ruler_len$sep$sep${(q)ruler_char}$sep)}%k%f"
      _P9K_LEFT_PREFIX+='$_P9K_T[$((3+!_P9K_IND))]'
    else
      print -P "%F{red}WARNING!%f %BPOWERLEVEL9K_RULER_CHAR%b is not one character long. Ruler won't be rendered."
      print -P "Either change the value of %BPOWERLEVEL9K_RULER_CHAR%b or set %BPOWERLEVEL9K_SHOW_RULER=false%b to"
      print -P "disable ruler."
    fi
  fi

  if [[ $ITERM_SHELL_INTEGRATION_INSTALLED == Yes ]]; then
    _P9K_LEFT_PREFIX+="%{$(iterm2_prompt_mark)%}"
  fi

  _P9K_LEFT_PREFIX+='${${_P9K_BG::=NONE}+}${${_P9K_I::=0}+}'
  _P9K_RIGHT_PREFIX+='${${_P9K_BG::=NONE}+}${${_P9K_I::=0}+}'

  _p9k_get_icon LEFT_SEGMENT_SEPARATOR
  _P9K_T=("%f$_P9K_RETVAL" "" $'\n')
  _p9k_prompt_overflow_bug && _P9K_T+='%{%G%}' || _P9K_T+=''

  _P9K_RIGHT_SUFFIX+='%f%b%k'
  _P9K_RIGHT_PREFIX+='%f%b%k'

  if [[ $POWERLEVEL9K_PROMPT_ON_NEWLINE == true ]]; then
    _p9k_get_icon MULTILINE_FIRST_PROMPT_PREFIX
    _P9K_LEFT_PREFIX+="$_P9K_RETVAL%f%b%k"
    _p9k_get_icon MULTILINE_LAST_PROMPT_PREFIX
    _P9K_LEFT_SUFFIX+=$'\n'$_P9K_RETVAL
    if [[ $POWERLEVEL9K_RPROMPT_ON_NEWLINE != true ]]; then
      if is-at-least 5.3; then
        function _p9k_zle_line_finish() {
          [[ -o TRANSIENT_RPROMPT ]] || return
          _P9K_RPROMPT_OVERRIDE=
          zle && zle .reset-prompt && zle -R
        }
        autoload -Uz add-zle-hook-widget
        zle -N _p9k_zle_line_finish
        add-zle-hook-widget line-finish _p9k_zle_line_finish
        add-zle-hook-widget -D line-finish user:_zsh_highlight_widget_orig-\*
        add-zle-hook-widget -D line-finish user:_zsh_autosuggest_bound_\*
      fi
    fi
  else
    _P9K_LEFT_PREFIX+="%f%b%k"
  fi

  # If the terminal `LANG` is set to `C`, this theme will not work at all.
  if [[ $LANG == "C" && $POWERLEVEL9K_IGNORE_TERM_LANG == false ]]; then
    print -P "\t%F{red}WARNING!%f Your terminal's 'LANG' is set to 'C', which breaks this theme!"
    print -P "\t%F{red}WARNING!%f Please set your 'LANG' to a UTF-8 language, like 'en_US.UTF-8'"
    print -P "\t%F{red}WARNING!%f _before_ loading this theme in your \~\.zshrc. Putting"
    print -P "\t%F{red}WARNING!%f %F{blue}export LANG=\"en_US.UTF-8\"%f at the top of your \~\/.zshrc is sufficient."
    print -P 'Set POWERLEVEL9K_IGNORE_TERM_LANG=true to suppress this warning.'
  fi

  # Display a warning if the terminal does not support 256 colors.
  if [[ $POWERLEVEL9K_IGNORE_TERM_COLORS == false ]]; then
    if zmodload zsh/terminfo 2>/dev/null && (( $+terminfo[colors] && $terminfo[colors] < 256 )); then
      print -P '%F{red}WARNING!%f Your terminal appears to support fewer than 256 colors!'
      print -P 'If your terminal supports 256 colors, please export the appropriate environment variable.'
      print -P 'In most terminal emulators, adding %F{blue}export TERM=xterm-256color%f to your %F{yellow}~/.zshrc%f is sufficient.'
      print -P 'Set %F{blue}POWERLEVEL9K_IGNORE_TERM_COLORS=true%f to suppress this warning.'
    fi
  fi

  if segment_in_use longstatus; then
    print -P '%F{yellow}WARNING!%f The "longstatus" segment is deprecated. Use "%F{blue}status%f" instead.'
    print -P 'For more informations, have a look at https://github.com/bhilburn/powerlevel9k/blob/master/CHANGELOG.md.'
  fi

  if segment_in_use vcs; then
    powerlevel9k_vcs_init
    if [[ $POWERLEVEL9K_DISABLE_GITSTATUS != true ]] && (( ${POWERLEVEL9K_VCS_BACKENDS[(I)git]} )); then
      source ${POWERLEVEL9K_GITSTATUS_DIR:-${_p9k_installation_dir}/gitstatus}/gitstatus.plugin.zsh
      gitstatus_start                                                                 \
        -s ${POWERLEVEL9K_VCS_MAX_NUM_STAGED:-$POWERLEVEL9K_VCS_STAGED_MAX_NUM}       \
        -u ${POWERLEVEL9K_VCS_MAX_NUM_UNSTAGED:-$POWERLEVEL9K_VCS_UNSTAGED_MAX_NUM}   \
        -d ${POWERLEVEL9K_VCS_MAX_NUM_UNTRACKED:-$POWERLEVEL9K_VCS_UNTRACKED_MAX_NUM} \
        -m $POWERLEVEL9K_VCS_MAX_INDEX_SIZE_DIRTY                                     \
        POWERLEVEL9K
    fi
  fi

  if segment_in_use vi_mode && (( $+POWERLEVEL9K_VI_VISUAL_MODE_STRING )); then
    if is-at-least 5.3; then
      function _p9k_zle_line_pre_redraw() {
        [[ $KEYMAP == vicmd ]] &&
          [[ ${REGION_ACTIVE:-0} != $_P9K_REGION_ACTIVE ]] &&
          _P9K_REGION_ACTIVE=${REGION_ACTIVE:-0} &&
          zle && zle .reset-prompt && zle -R
      }
      autoload -Uz add-zle-hook-widget
      add-zle-hook-widget line-pre-redraw _p9k_zle_line_pre_redraw
      add-zle-hook-widget -D line-pre-redraw user:_zsh_highlight_widget_orig-\*
      add-zle-hook-widget -D line-pre-redraw user:_zsh_autosuggest_bound_\*
      _p9k_g_expand POWERLEVEL9K_VI_VISUAL_MODE_STRING
    else
      >&2 print -P '%F{yellow}WARNING!%f POWERLEVEL9K_VI_VISUAL_MODE_STRING requires ZSH >= 5.3.'
      >&2 print -r "Your zsh version is $ZSH_VERSION. Either upgrade zsh or unset POWERLEVEL9K_VI_VISUAL_MODE_STRING."
    fi
  fi

  if segment_in_use dir &&
     [[ $POWERLEVEL9K_SHORTEN_STRATEGY == truncate_with_package_name && $+commands[jq] == 0 ]]; then
    >&2 print -P '%F{yellow}WARNING!%f %BPOWERLEVEL9K_SHORTEN_STRATEGY=truncate_with_package_name%b requires %F{green}jq%f.'
    >&2 print -P 'Either install %F{green}jq%f or change the value of %BPOWERLEVEL9K_SHORTEN_STRATEGY%b.'
  fi

  zle -N zle-keymap-select _p9k_zle_keymap_select

  _P9K_INITIALIZED=1
}

prompt_mattnew_setup() {
  prompt_powerlevel9k_teardown

  add-zsh-hook precmd powerlevel9k_prepare_prompts
  add-zsh-hook preexec powerlevel9k_preexec

  _P9K_TIMER_START=1e10
  _P9K_ENABLED=1
}

prompt_powerlevel9k_teardown() {
  add-zsh-hook -D precmd powerlevel9k_\*
  add-zsh-hook -D preexec powerlevel9k_\*
  PROMPT='%m%# '
  RPROMPT=
  _P9K_ENABLED=0
}

autoload -U colors && colors
autoload -Uz add-zsh-hook

zmodload zsh/datetime
zmodload zsh/mathfunc
zmodload zsh/system
zmodload -F zsh/stat b:zstat

prompt_mattnew_setup

source "${_p9k_installation_dir}/functions/purepower"
