# vim:ft=bash

_riff_installation_dir="$HOME/.completions/theme"

## Configurables
typeset -g  RIFF_LEFT_SEPARATOR=""
typeset -g  RIFF_RIGHT_SEPARATOR=""
typeset -ga RIFF_LEFT_PROMPT_ELEMENTS
typeset -ga RIFF_RIGHT_PROMPT_ELEMENTS
typeset -gi RIFF_PROFILER=0
typeset -g  RIFF_PROMPT_END
typeset -g  RIFF_LINE_LINKS="true"
typeset -g  RIFF_TL_LINK="╭"
typeset -g  RIFF_BL_LINK="╰"
typeset -g  RIFF_TR_LINK="╮"
typeset -g  RIFF_BR_LINK="╯"
typeset -g  RIFF_ML_LINK="├"
typeset -g  RIFF_MR_LINK="┤"
typeset -g  RIFF_NL_LINK="│"

RIFF_LEFT_PROMPT_ELEMENTS=(root_indicator dir ruler php_version context user newline )
RIFF_RIGHT_PROMPT_ELEMENTS=(command_execution_time history date background_jobs)

## Necessary global variables
typeset -Ag _RIFF_CACHE
typeset -g  _RIFF_EXIT_CODE        # Capture command exit code
typeset -g  _RIFF_RETURN_MESSAGE   # Used as a temporary storage for values to avoid using subshells
typeset -gi _RIFF_BREAK_CACHE_COUNTER
typeset -ga _RIFF_LINES_META
typeset -gi _RIFF_CURRENT_RPROMPT=1
typeset -gi _RIFF_LEFT_TEXT_LENGTH=0
typeset -gi _RIFF_RIGHT_TEXT_LENGTH=0
typeset -gi _RIFF_LAST_TEXT_LENGTH=0
typeset -g  _RIFF_NEWLINE='
'

source "${_riff_installation_dir}/lib/colors.zsh"
source "${_riff_installation_dir}/lib/icons.zsh"
source "${_riff_installation_dir}/lib/utilities.zsh"

## Call module to generate prompt text
# Must set _RIFF_RETURN_MESSAGE and _RIFF_LEFT_TEXT_LENGTH
_riff_set_module_text() {

  local module module_text fg_color bg_color transition_fg_color
  local -u fg_var bg_var # Convert variable names to upper case when checking config

  module="$1"

  fg_var="RIFF_${module}_FG"
  bg_var="RIFF_${module}_BG"

  "_riff_${module}_run"

  _RIFF_LAST_TEXT_LENGTH="${#${(%)_RIFF_RETURN_MESSAGE}}"

  if ((_RIFF_LAST_TEXT_LENGTH == 0)); then
    _RIFF_RETURN_MESSAGE=""
    return;
  fi

  module_text=" ${_RIFF_RETURN_MESSAGE} "
  ((_RIFF_LAST_TEXT_LENGTH+=2));

  _riff_translate_color "${(P)${fg_var}}"
  fg_color="${_RIFF_RETURN_MESSAGE}"

  _riff_foreground "${fg_color}"
  fg_color="${_RIFF_RETURN_MESSAGE}"

  _riff_translate_color "${(P)${bg_var}}"
  bg_color="${_RIFF_RETURN_MESSAGE}"

  _riff_foreground "${bg_color}"
  transition_fg_color="${_RIFF_RETURN_MESSAGE}"

  _riff_background "${bg_color}"
  bg_color="${_RIFF_RETURN_MESSAGE}"

  _RIFF_RETURN_MESSAGE="${fg_color}${bg_color}${module_text}${transition_fg_color}"

}

## Retrieve text from prompt module.
# Must either set _RIFF_RETURN_MESSAGE and _RIFF_LEFT_TEXT_LENGTH
# using date from cache, or pass to _riff_set_module_text
_riff_get_module_text() {

  local module start

  module="$1"

  if ((RIFF_PROFILER > 0)); then
    start=${EPOCHREALTIME}
  fi

  # if has cache; then
  #   TODO
  # else
  _riff_set_module_text "$module"
  # fi

  if ((RIFF_PROFILER > 0)); then
    printf "%25s: %f\n" "$module" "$((EPOCHREALTIME-start))"
  fi

}

# Separator logic
_riff_add_separator() {

  local prompt_side current_module transition_bg_color transition_fg_color
  local -u bg_var

  prompt_side="$1"
  current_module="$2"

  bg_var="RIFF_${current_module}_BG"

  if [[ "$prompt_side" == "left" ]]; then

    if (( _RIFF_LEFT_TEXT_LENGTH > 0 )); then

      if [[ "$current_module" == "newline" ]]; then
        transition_bg_color="%k"
      else

        _riff_translate_color "${(P)${bg_var}}"
        transition_bg_color="${_RIFF_RETURN_MESSAGE}"

        _riff_background "${transition_bg_color}"
        transition_bg_color="${_RIFF_RETURN_MESSAGE}"
      fi

      _RIFF_RETURN_MESSAGE="${transition_bg_color}${RIFF_LEFT_SEPARATOR}%f"
      ((_RIFF_LEFT_TEXT_LENGTH+=${#RIFF_LEFT_SEPARATOR}));

    else
      _RIFF_RETURN_MESSAGE="%f%k"
    fi

  else

    _riff_translate_color "${(P)${bg_var}}"
    transition_fg_color="${_RIFF_RETURN_MESSAGE}"

    _riff_foreground "${transition_fg_color}"
    transition_fg_color="${_RIFF_RETURN_MESSAGE}"

    _RIFF_RETURN_MESSAGE="${transition_fg_color}${RIFF_RIGHT_SEPARATOR}"
    ((_RIFF_RIGHT_TEXT_LENGTH+=${#RIFF_RIGHT_SEPARATOR}));
  fi

}

_riff_add_newline() {

  local current_module faux_rprompt columns fill_line line_index
  current_module="$1"

  line_index="$2"

  _riff_add_separator "left" "newline"
  prompt_lines[line_index]+="${_RIFF_RETURN_MESSAGE}"

  _riff_make_rprompt
  faux_rprompt="${_RIFF_RETURN_MESSAGE}"

  if [[ "$RIFF_LINE_LINKS" == "true" ]]; then
    if (( _RIFF_LEFT_TEXT_LENGTH > 0 )); then
      ((_RIFF_LINES_META[line_index]+=1));
      ((_RIFF_LEFT_TEXT_LENGTH+1));
    fi
    if (( _RIFF_RIGHT_TEXT_LENGTH > 0 )); then
      ((_RIFF_LINES_META[line_index]+=2));
      ((_RIFF_RIGHT_TEXT_LENGTH+1));
    fi
  fi

  (( columns = $COLUMNS - _RIFF_LEFT_TEXT_LENGTH - _RIFF_RIGHT_TEXT_LENGTH ));

  if [[ "${current_module}" == "newline" ]]; then
    fill_line="${(l.${columns}.. .)}"
  else
    fill_line="${(l.${columns}..─.)}"
  fi

  _RIFF_RETURN_MESSAGE="${fill_line}${faux_rprompt}%f%k"

  _RIFF_RIGHT_TEXT_LENGTH=0;
  _RIFF_LEFT_TEXT_LENGTH=0;
}

## Assemble left prompt
_riff_set_left_prompt() {

  local element length module_text current_module
  local -i line_index
  local -a prompt_lines

  line_index=1;
  length="${#RIFF_LEFT_PROMPT_ELEMENTS[@]}"

  for ((element=1; element<=length;element++)); do

    current_module="${RIFF_LEFT_PROMPT_ELEMENTS[element]}"

    if [[ "${current_module}" == "newline" || "${current_module}" == "ruler" ]]; then

      _riff_add_newline "${current_module}" "${line_index}"

      prompt_lines[line_index]+="${_RIFF_RETURN_MESSAGE}"

      ((line_index++));

    else

      _riff_get_module_text "$current_module"
      module_text="${_RIFF_RETURN_MESSAGE}"

      if [[ -n "${module_text}" ]]; then

        _riff_add_separator "left" "$current_module"
        prompt_lines[line_index]+="${_RIFF_RETURN_MESSAGE}"

        prompt_lines[line_index]+="${module_text}"
        ((_RIFF_LEFT_TEXT_LENGTH+=_RIFF_LAST_TEXT_LENGTH));

      fi

    fi

  done

  _riff_add_separator "left" "newline"
  prompt_lines[line_index]+="${_RIFF_RETURN_MESSAGE}"

  for ((line=1;line<=line_index;line++)); do

    PROMPT+="${prompt_lines[line]}"

    if ((line < line_index)); then
      PROMPT+="${_RIFF_NEWLINE}"
    fi

  done

  _RIFF_LINES_META=();

}

## Assemble a right prompt line
_riff_make_rprompt(){

  local length module_text current_module rprompt

  length="${#RIFF_RIGHT_PROMPT_ELEMENTS[@]}"

  while ((_RIFF_CURRENT_RPROMPT <= length)); do

    current_module="${RIFF_RIGHT_PROMPT_ELEMENTS[_RIFF_CURRENT_RPROMPT]}"
    ((_RIFF_CURRENT_RPROMPT++));

    if [[ "${current_module}" == "newline" ]]; then
      break;
    else

      _riff_get_module_text "${current_module}"
      module_text="${_RIFF_RETURN_MESSAGE}"

      if [[ -n "${module_text}" ]]; then

        _riff_add_separator "right" "${current_module}"
        rprompt+="${_RIFF_RETURN_MESSAGE}"

        rprompt+="${module_text}"
        ((_RIFF_RIGHT_TEXT_LENGTH+=_RIFF_LAST_TEXT_LENGTH));

      fi

    fi

  done

  _RIFF_RETURN_MESSAGE="${rprompt}"

}

_riff_set_prompts(){

  _riff_set_left_prompt

  _riff_make_rprompt
  RPROMPT="${_RIFF_RETURN_MESSAGE}"

  _RIFF_CURRENT_RPROMPT=1

}

_riff_precmd() {

  local start

  _RIFF_EXIT_CODE=$?
  #_RIFF_PIPE_EXIT_CODES=( "$pipestatus[@]" )

  _RIFF_LEFT_TEXT_LENGTH=0;
  _RIFF_RIGHT_TEXT_LENGTH=0;
  PROMPT=""
  RPROMPT=""
  #ZLE_RPROMPT_INDENT=0

  # Forcefully refresh cache by pressing enter a few times
  if ((_RIFF_BREAK_CACHE_COUNTER++ >= 2)); then
    _RIFF_CACHE=();
    _RIFF_BREAK_CACHE_COUNTER=0;
  fi

  if ((RIFF_PROFILER > 0)); then
    start="$EPOCHREALTIME"
  fi

  _riff_set_prompts

  if ((RIFF_PROFILER > 0)); then
    printf "%25s: %f\n" "Total" "$((EPOCHREALTIME-start))"
  fi

}

_riff_preexec() {

  # Run preexec hooks for modules
  for element in "${RIFF_LEFT_PROMPT_ELEMENTS[@]}" "${RIFF_RIGHT_PROMPT_ELEMENTS[@]}"; do
    if typeset -f "_riff_${element}_module_preexec" > /dev/null; then
      "_riff_${element}_module_preexec";
    fi
  done

  # Reset break cache counter anytime a command is run.
  _RIFF_BREAK_CACHE_COUNTER=0;

}

prompt_riff_setup() {

  local element

  autoload -U colors && colors
  autoload -Uz add-zsh-hook

  zmodload zsh/datetime
  zmodload zsh/mathfunc
  zmodload zsh/system
  zmodload -F zsh/stat b:zstat

  add-zsh-hook precmd _riff_precmd
  add-zsh-hook preexec _riff_preexec


  #_riff_init_icons

  # Load enabled modules and run setup hooks
  for element in "${RIFF_LEFT_PROMPT_ELEMENTS[@]}" "${RIFF_RIGHT_PROMPT_ELEMENTS[@]}"; do

    if [[ -f "${_riff_installation_dir}/modules/${element}" ]]; then

      source "${_riff_installation_dir}/modules/${element}";

      if typeset -f "_riff_${element}_module_setup" > /dev/null; then
        "_riff_${element}_module_setup";
      fi

    fi

  done

}

prompt_riff_setup
