# vim:ft=bash

_riff_installation_dir="$HOME/.completions/theme"

## Configurables
typeset -g  RIFF_LEFT_SEPARATOR
typeset -g  RIFF_RIGHT_SEPARATOR
typeset -ga RIFF_LEFT_PROMPT_ELEMENTS
typeset -ga RIFF_RIGHT_PROMPT_ELEMENTS

RIFF_LEFT_SEPARATOR=""
RIFF_RIGHT_SEPARATOR=""
RIFF_LEFT_PROMPT_ELEMENTS=(user context php_version)
RIFF_RIGHT_PROMPT_ELEMENTS=(command_execution_time date background_jobs)

## Necessary global variables
typeset -g _RIFF_EXIT_CODE        # Capture command exit code
typeset -g _RIFF_RETURN_MESSAGE   # Used as a temporary storage for values to avoid using subshells

source "${_riff_installation_dir}/lib/colors.zsh"
source "${_riff_installation_dir}/lib/icons.zsh"

_riff_set_module_text() {

  local module module_text fg_color bg_color transition_color
  local -u fg_var bg_var # Convert module name to upper case when checking config

  module="$1"

  fg_var="RIFF_${module}_FG"
  bg_var="RIFF_${module}_BG"

  "_riff_${module}_run"

  if [[ -z "${_RIFF_RETURN_MESSAGE}" ]]; then
    _RIFF_RETURN_MESSAGE=""
    return;
  fi

  module_text="${_RIFF_RETURN_MESSAGE}"

  _riff_translate_color "${(P)${fg_var}}"
  fg_color="${_RIFF_RETURN_MESSAGE}"

  _riff_foreground "${fg_color}"
  fg_color="${_RIFF_RETURN_MESSAGE}"

  _riff_translate_color "${(P)${bg_var}}"
  bg_color="${_RIFF_RETURN_MESSAGE}"

  _riff_foreground "${bg_color}"
  transition_color="${_RIFF_RETURN_MESSAGE}"

  _riff_background "${bg_color}"
  bg_color="${_RIFF_RETURN_MESSAGE}"

  _RIFF_RETURN_MESSAGE="${fg_color}${bg_color} ${module_text} ${transition_color}"

}

_riff_get_module_text() {

  local module

  module="$1"

  # if has cache; then
  #   TODO
  # else
  _riff_set_module_text "$module"
  # fi

}

_riff_set_prompt(){

  local element left_length right_length module_text
  local -u current_module
  local -u fg_var bg_var # Convert module name to upper case when checking config

  left_length="${#RIFF_LEFT_PROMPT_ELEMENTS[@]}"
  right_length="${#RIFF_RIGHT_PROMPT_ELEMENTS[@]}"

  for ((element=1; element<=${left_length};element++)); do

    _riff_get_module_text "${RIFF_LEFT_PROMPT_ELEMENTS[element]}"
    module_text="${_RIFF_RETURN_MESSAGE}"

    if [[ -n "${_RIFF_RETURN_MESSAGE}" ]]; then

      if ((element > 1)); then

        current_module="${RIFF_LEFT_PROMPT_ELEMENTS[element]}"

        fg_var="RIFF_${current_module}_FG"
        bg_var="RIFF_${current_module}_BG"

        _riff_translate_color "${(P)${bg_var}}"
        bg_color="${_RIFF_RETURN_MESSAGE}"

        _riff_background "${bg_color}"
        bg_color="${_RIFF_RETURN_MESSAGE}"

        PROMPT+="${bg_color}${RIFF_LEFT_SEPARATOR}"

      fi

      PROMPT+="${module_text}"

    fi

  done

  PROMPT+="%k${RIFF_LEFT_SEPARATOR}%f "

  for ((element=1; element<=${right_length};element++)); do

    _riff_get_module_text "${RIFF_RIGHT_PROMPT_ELEMENTS[element]}"
    module_text="${_RIFF_RETURN_MESSAGE}"

    if [[ -n "${_RIFF_RETURN_MESSAGE}" ]]; then

      if ((element > 1)); then

        current_module="RIFF_${RIFF_RIGHT_PROMPT_ELEMENTS[element]}"

        _riff_translate_color "${${(P)current_module}_BG}"
        bg_color="${_RIFF_RETURN_MESSAGE}"

        _riff_background "${bg_color}"
        bg_color="${_RIFF_RETURN_MESSAGE}"

        RPROMPT+="${bg_color}${RIFF_RIGHT_SEPARATOR}"

      fi

      RPROMPT+="${module_text}"

    fi

  done

  RPROMPT+="%f%k"

}

_riff_precmd() {

  _RIFF_EXIT_CODE=$?
  #_RIFF_PIPE_EXIT_CODES=( "$pipestatus[@]" )

  PROMPT=""
  RPROMPT=""

  _riff_set_prompt

}

_riff_preexec() {

  # Run preexec hooks for modules
  for element in "${RIFF_LEFT_PROMPT_ELEMENTS[@]}" "${RIFF_RIGHT_PROMPT_ELEMENTS[@]}"; do
    if typeset -f "_riff_${element}_module_preexec" > /dev/null; then
      "_riff_${element}_module_preexec";
    fi
  done

}

prompt_riff_setup() {

  local element

  autoload -U colors && colors
  autoload -Uz add-zsh-hook

  zmodload zsh/datetime
  zmodload zsh/mathfunc
  zmodload zsh/system
  zmodload -F zsh/stat b:zstat

  add-zsh-hook precmd _riff_precmd
  add-zsh-hook preexec _riff_preexec

  #_riff_init_icons

  # Load enabled modules and run setup hooks
  for element in "${RIFF_LEFT_PROMPT_ELEMENTS[@]}" "${RIFF_RIGHT_PROMPT_ELEMENTS[@]}"; do

    if [[ -f "${_riff_installation_dir}/modules/${element}" ]]; then

      source "${_riff_installation_dir}/modules/${element}";

      if typeset -f "_riff_${element}_module_setup" > /dev/null; then
        "_riff_${element}_module_setup";
      fi

    fi

  done

}

prompt_riff_setup
