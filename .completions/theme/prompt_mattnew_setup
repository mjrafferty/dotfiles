# vim:ft=bash

_p9k_installation_dir="$HOME/.completions"

source "${_p9k_installation_dir}/lib/utilities.zsh"
source "${_p9k_installation_dir}/lib/defaults.zsh"
source "${_p9k_installation_dir}/lib/cache.zsh"
source "${_p9k_installation_dir}/lib/timer.zsh"
source "${_p9k_installation_dir}/lib/icons.zsh"
source "${_p9k_installation_dir}/lib/colors.zsh"
source "${_p9k_installation_dir}/lib/vcs.zsh"

typeset  -g   _P9K_RETVAL
typeset  -g   _P9K_CACHE_KEY
typeset  -ga  _P9K_CACHE_VAL
typeset  -gA  _P9K_CACHE
typeset  -ga  _P9K_T
typeset  -g   _P9K_N
typeset  -gi  _P9K_I
typeset  -g   _P9K_BG
typeset  -g   _P9K_F
typeset  -ga  _P9K_LEFT_JOIN=(1)
typeset  -ga  _P9K_RIGHT_JOIN=(1)
typeset  -g   _P9K_XY _P9K_ALIGNED_RPROMPT
typeset  -gi  _P9K_X _P9K_Y _P9K_M _P9K_RPROMPT_DONE_P9K_IND
typeset  -gF  _P9K_TIMER_START
typeset  -g   _P9K_PROMPT
typeset  -g   _P9K_RPROMPT
typeset  -g   _P9K_LEFT_PREFIX
typeset  -g   _P9K_LEFT_SUFFIX
typeset  -g   _P9K_RIGHT_PREFIX
typeset  -g   _P9K_RIGHT_SUFFIX
typeset  -g   _P9K_REFRESH_REASON
typeset  -gi  _P9K_REGION_ACTIVE
typeset  -g   DEFAULT_COLOR
typeset  -g   DEFAULT_COLOR_INVERTED
typeset  -gi  _P9K_INITIALIZED=0
typeset  -g   OS
typeset  -g   OS_ICON
typeset  -g   SED_EXTENDED_REGEX_PARAMETER
typeset  -g   _P9K_TIMER_FIFO
typeset  -gi  _P9K_TIMER_FD=0
typeset  -gi  _P9K_TIMER_PID=0
typeset  -gi  _P9K_TIMER_SUBSHELL=0
typeset  -gi  _P9K_ENABLED=0

################################################################
# The 'custom` prompt provides a way for users to invoke commands and display
# the output in a segment.
prompt_custom() {
  local segment_name="${3:u}"
  # Get content of custom segment
  local command="POWERLEVEL9K_CUSTOM_${segment_name}"
  local -a cmd=("${(@Q)${(z)${(P):-POWERLEVEL9K_CUSTOM_${segment_name}}}}")
  whence $cmd[1] &>/dev/null || return
  local content=$("$cmd[@]")
  [[ -n $content ]] || return
  "$1_prompt_segment" "${0}_${3:u}" "$2" $DEFAULT_COLOR_INVERTED $DEFAULT_COLOR "CUSTOM_${segment_name}_ICON" 0 '' "$content"
}

_p9k_set_prompt() {
  emulate -L zsh
  PROMPT=
  RPROMPT=
  if [[ $POWERLEVEL9K_DISABLE_RPROMPT == true ]]; then
    _P9K_RPROMPT_DONE=1
  else
    _P9K_PROMPT=
    build_right_prompt
    local right=$_P9K_RIGHT_PREFIX$_P9K_PROMPT$_P9K_RIGHT_SUFFIX
    if [[ $POWERLEVEL9K_PROMPT_ON_NEWLINE != true || $POWERLEVEL9K_RPROMPT_ON_NEWLINE == true ]]; then
      RPROMPT=$right
      _P9K_RPROMPT_DONE=1
    else
      unset _P9K_RPROMPT_OVERRIDE
      PROMPT="\${\${_P9K_RPROMPT::=\${_P9K_RPROMPT_OVERRIDE-$right}}+}"
      _P9K_RPROMPT_DONE=0
    fi
  fi

  _P9K_PROMPT=''
  if build_left_prompt; then
    PROMPT+=$_P9K_LEFT_PREFIX$_P9K_PROMPT$_P9K_LEFT_SUFFIX
  else
    PROMPT+=$_P9K_LEFT_PREFIX$_P9K_PROMPT${_P9K_LEFT_SUFFIX#$'\n'}
  fi
}

left_prompt_segment() {
# Begin a left prompt segment.
#
#    * $1: Name of the function that was originally invoked.
#          Necessary, to make the dynamic color-overwrite mechanism work.
#    * $2: The array index of the current segment.
#    * $3: Background color.
#    * $4: Foreground color.
#    * $5: An identifying icon (must be a key of the icons array).
#    * $6: 1 to to perform parameter expansion and process substitution.
#    * $7: If not empty but becomes empty after parameter expansion and process substitution,
#          the segment isn't rendered.
#   * $8+: The segment content
  if ! _p9k_cache_get "$0" "$1" "$2" "$3" "$4" "$5"; then
    _p9k_color $3 $1 BACKGROUND
    local bg_color=$_P9K_RETVAL
    _p9k_background $bg_color
    local bg=$_P9K_RETVAL

    _p9k_color $4 $1 FOREGROUND
    local fg_color=$_P9K_RETVAL
    _p9k_foreground $fg_color
    local fg=$_P9K_RETVAL

    _p9k_get_icon LEFT_SUBSEGMENT_SEPARATOR
    local subsep=$_P9K_RETVAL

    _p9k_escape_rcurly $POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS
    local space=$_P9K_RETVAL

    local icon
    local -i has_icon
    if [[ -n $5 ]]; then
      _p9k_get_icon $5
      if [[ -n $_P9K_RETVAL ]]; then
        local glyph=$_P9K_RETVAL
        _p9k_color $fg_color $1 VISUAL_IDENTIFIER_COLOR
        _p9k_foreground $_P9K_RETVAL
        icon=$_P9K_RETVAL$glyph
        has_icon=1
      fi
    fi

    # Segment separator logic:
    #
    #   if [[ $_P9K_BG == NONE ]]; then
    #     1
    #   elif (( joined )); then
    #     2
    #   elif [[ $bg_color == $_P9K_BG ]]; then
    #     3
    #   else
    #     4
    #   fi

    local t=$#_P9K_T
    _P9K_T+=$bg$POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS$icon                         # 1
    _P9K_T+=$bg$icon                                                                       # 2
    if [[ -z $fg_color ]]; then
      _p9k_foreground $DEFAULT_COLOR
      _P9K_T+=$bg$_P9K_RETVAL$subsep$POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS$icon    # 3
    else
      _P9K_T+=$bg$fg$subsep$POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS$icon             # 3
    fi
    _p9k_get_icon LEFT_SEGMENT_SEPARATOR
    _P9K_T+=$bg$_P9K_RETVAL$POWERLEVEL9K_WHITESPACE_BETWEEN_LEFT_SEGMENTS$icon             # 4

    local pre
    pre+="\${_P9K_N::=}\${_P9K_F::=}"
    pre+="\${\${\${_P9K_BG:-0}:#NONE}:-\${_P9K_N::=$((t+1))}}"                        # 1
    pre+="\${_P9K_N:=\${\${\$((_P9K_I>=$_P9K_LEFT_JOIN[$2])):#0}:+$((t+2))}}"         # 2
    pre+="\${_P9K_N:=\${\${\$((!\${#\${:-0\$_P9K_BG}:#0$bg_color})):#0}:+$((t+3))}}"  # 3
    pre+="\${_P9K_N:=\${\${_P9K_F::=%F{\$_P9K_BG\}}+$((t+4))}}}+}"                    # 4
    pre+="%b\${_P9K_F}\${_P9K_T[\$_P9K_N]}"

    _p9k_escape_rcurly %b$bg$fg
    local post="\${_P9K_C}$_P9K_RETVAL$space\${\${_P9K_I::=$2}+}\${\${_P9K_BG::=$bg_color}+}}"

    _p9k_cache_set $has_icon $_P9K_RETVAL $pre $post
  fi

  local name=$1
  local -i has_icon=${_P9K_CACHE_VAL[1]}
  local style=${_P9K_CACHE_VAL[2]}
  local -i expand=$6
  local cond=${7:-1}
  shift 7

    local content="${(j::):-$style${^@}}"
  (( expand )) || content="\${(Q)\${:-${(qqq)content}}}"

  _P9K_PROMPT+="\${\${:-$cond}:+\${\${:-\${_P9K_C::=${content}}${_P9K_CACHE_VAL[3]}"
  (( has_icon )) && _P9K_PROMPT+='${${(%):-$_P9K_C%1(l. .x)}[-1]%x}'
  _P9K_PROMPT+=${_P9K_CACHE_VAL[4]}
}

right_prompt_segment() {
# The same as left_prompt_segment above but for the right prompt.
  if ! _p9k_cache_get "$0" "$1" "$2" "$3" "$4" "$5"; then
    _p9k_color $3 $1 BACKGROUND
    local bg_color=$_P9K_RETVAL
    _p9k_background $bg_color
    local bg=$_P9K_RETVAL

    _p9k_color $4 $1 FOREGROUND
    local fg_color=$_P9K_RETVAL
    _p9k_foreground $fg_color
    local fg=$_P9K_RETVAL

    _p9k_get_icon RIGHT_SUBSEGMENT_SEPARATOR
    local subsep=$_P9K_RETVAL

    local icon_style icon
    local -i has_icon
    if [[ -n $5 ]]; then
      _p9k_get_icon $5
      if [[ -n $_P9K_RETVAL ]]; then
        _p9k_escape_rcurly $_P9K_RETVAL
        icon=$_P9K_RETVAL
        _p9k_color $fg_color $1 VISUAL_IDENTIFIER_COLOR
        _p9k_foreground $_P9K_RETVAL
        _p9k_escape_rcurly %b$bg$_P9K_RETVAL
        icon_style=$_P9K_RETVAL
        has_icon=1
      fi
    fi

    # Segment separator logic is the same as in left_prompt_segment except that here #4 and #1 are
    # identical.

    local t=$#_P9K_T
    _p9k_get_icon RIGHT_SEGMENT_SEPARATOR
    _P9K_T+="%F{$bg_color}$_P9K_RETVAL$bg$POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS$fg"  # 1
    _P9K_T+=$fg                                                                               # 2
    if [[ -z $fg_color ]]; then
      _p9k_foreground $DEFAULT_COLOR
      _P9K_T+=$bg$_P9K_RETVAL$subsep$POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS$fg        # 3
    else
      _P9K_T+=$bg$fg$subsep$POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS                    # 3
    fi

    local pre
    pre+="\${_P9K_N::=}"
    pre+="\${\${\${_P9K_BG:-0}:#NONE}:-\${_P9K_N::=$((t+1))}}"                        # 1
    pre+="\${_P9K_N:=\${\${\$((_P9K_I>=$_P9K_RIGHT_JOIN[$2])):#0}:+$((t+2))}}"        # 2
    pre+="\${_P9K_N:=\${\${\$((!\${#\${:-0\$_P9K_BG}:#0$bg_color})):#0}:+$((t+3))}}"  # 3
    pre+="\${_P9K_N:=$((t+1))}}+}"                                                    # 4 == 1
    pre+="\${_P9K_T[\$_P9K_N]}\${_P9K_C}$icon_style"

    _p9k_escape_rcurly $POWERLEVEL9K_WHITESPACE_BETWEEN_RIGHT_SEGMENTS
    local space=$_P9K_RETVAL
    _p9k_escape_rcurly %b$bg$fg
    local post="$icon$_P9K_RETVAL$space\${\${_P9K_I::=$2}+}\${\${_P9K_BG::=$bg_color}+}}"

    _p9k_cache_set $has_icon $_P9K_RETVAL $pre $post
  fi

  local -i has_icon=${_P9K_CACHE_VAL[1]}
  local style=${_P9K_CACHE_VAL[2]}
  local -i expand=$6
  local cond=${7:-1}
  shift 7

  _p9k_escape_rcurly $style
  local content="${(j::):-$_P9K_RETVAL${^@}}"
  (( expand )) || content="\${(Q)\${:-${(qqq)content}}}"

  _P9K_PROMPT+="\${\${:-$cond}:+\${\${:-\${_P9K_C::=${content}}${_P9K_CACHE_VAL[3]}"
  (( has_icon )) && _P9K_PROMPT+='${${(%):-$_P9K_C%1(l. .x)}[-1]%x}'
  _P9K_PROMPT+=${_P9K_CACHE_VAL[4]}
}

build_left_prompt() {
  local -i index=1
  local element
  for element in "${POWERLEVEL9K_LEFT_PROMPT_ELEMENTS[@]}"; do
    # Remove joined information in direct calls
    element=${element%_joined}

    # Check if it is a custom command, otherwise interpet it as
    # a prompt.
    if [[ $element == custom_* ]]; then
      "prompt_custom" "left" "$index" $element[8,-1]
    else
      (( $+functions[prompt_$element] )) && "prompt_$element" "left" "$index"
    fi

    ((++index))
  done

  _p9k_get_icon LEFT_SEGMENT_END_SEPARATOR
  _p9k_left_prompt_end_line $_P9K_RETVAL
}

build_right_prompt() {
  local -i index=1
  local element

  for element in "${POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS[@]}"; do
    # Remove joined information in direct calls
    element=${element%_joined}

    # Check if it is a custom command, otherwise interpet it as
    # a prompt.
    if [[ $element == custom_* ]]; then
      "prompt_custom" "right" "$index" $element[8,-1]
    else
      (( $+functions[prompt_$element] )) && "prompt_$element" "right" "$index"
    fi

    ((++index))
  done
}

_p9k_init() {
  (( _P9K_INITIALIZED )) && return

  _p9k_init_icons
  _p9k_init_strings

  function _$0_set_os() {
    OS=$1
    _p9k_get_icon $2
    OS_ICON=$_P9K_RETVAL
  }

  trap "unfunction _$0_set_os" EXIT

  if [[ $(uname -o 2>/dev/null) == Android ]]; then
    _$0_set_os Android ANDROID_ICON
  else
    case $(uname) in
      SunOS)                     _$0_set_os Solaris SUNOS_ICON;;
      Darwin)                    _$0_set_os OSX     APPLE_ICON;;
      CYGWIN_NT-* | MSYS_NT-*)   _$0_set_os Windows WINDOWS_ICON;;
      FreeBSD|OpenBSD|DragonFly) _$0_set_os BSD     FREEBSD_ICON;;
      Linux)
        OS='Linux'
        local os_release_id
        [[ -f /etc/os-release &&
          "${(f)$((</etc/os-release) 2>/dev/null)}" =~ "ID=([A-Za-z]+)" ]] && os_release_id="${match[1]}"
        case "$os_release_id" in
          *arch*)                  _$0_set_os Linux LINUX_ARCH_ICON;;
          *debian*)                _$0_set_os Linux LINUX_DEBIAN_ICON;;
          *raspbian*)              _$0_set_os Linux LINUX_RASPBIAN_ICON;;
          *ubuntu*)                _$0_set_os Linux LINUX_UBUNTU_ICON;;
          *elementary*)            _$0_set_os Linux LINUX_ELEMENTARY_ICON;;
          *fedora*)                _$0_set_os Linux LINUX_FEDORA_ICON;;
          *coreos*)                _$0_set_os Linux LINUX_COREOS_ICON;;
          *gentoo*)                _$0_set_os Linux LINUX_GENTOO_ICON;;
          *mageia*)                _$0_set_os Linux LINUX_MAGEIA_ICON;;
          *centos*)                _$0_set_os Linux LINUX_CENTOS_ICON;;
          *opensuse*|*tumbleweed*) _$0_set_os Linux LINUX_OPENSUSE_ICON;;
          *sabayon*)               _$0_set_os Linux LINUX_SABAYON_ICON;;
          *slackware*)             _$0_set_os Linux LINUX_SLACKWARE_ICON;;
          *linuxmint*)             _$0_set_os Linux LINUX_MINT_ICON;;
          *alpine*)                _$0_set_os Linux LINUX_ALPINE_ICON;;
          *aosc*)                  _$0_set_os Linux LINUX_AOSC_ICON;;
          *nixos*)                 _$0_set_os Linux LINUX_NIXOS_ICON;;
          *devuan*)                _$0_set_os Linux LINUX_DEVUAN_ICON;;
          *manjaro*)               _$0_set_os Linux LINUX_MANJARO_ICON;;
          *)                       _$0_set_os Linux LINUX_ICON;;
        esac
        ;;
    esac
  fi

  if [[ $POWERLEVEL9K_COLOR_SCHEME == light ]]; then
    DEFAULT_COLOR=white
    DEFAULT_COLOR_INVERTED=black
  else
    DEFAULT_COLOR=black
    DEFAULT_COLOR_INVERTED=white
  fi

  local i
  for ((i = 2; i <= $#POWERLEVEL9K_LEFT_PROMPT_ELEMENTS; ++i)); do
    local elem=$POWERLEVEL9K_LEFT_PROMPT_ELEMENTS[$i]
    if [[ $elem == *_joined ]]; then
      _P9K_LEFT_JOIN+=$_P9K_LEFT_JOIN[((i-1))]
    else
      _P9K_LEFT_JOIN+=$i
    fi
  done

  for ((i = 2; i <= $#POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS; ++i)); do
    local elem=$POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS[$i]
    if [[ $elem == *_joined ]]; then
      _P9K_RIGHT_JOIN+=$_P9K_RIGHT_JOIN[((i-1))]
    else
      _P9K_RIGHT_JOIN+=$i
    fi
  done

  if [[ $POWERLEVEL9K_EXPERIMENTAL_TIME_REALTIME == true ]]; then
    _p9k_init_timer
  fi

  _P9K_ALIGNED_RPROMPT='${${:-${_P9K_X::=0}${_P9K_Y::=$((COLUMNS+1))}'
  repeat 10; do
    _P9K_ALIGNED_RPROMPT+='${_P9K_M::=$(((_P9K_X+_P9K_Y)/2))}'
    _P9K_ALIGNED_RPROMPT+='${_P9K_XY::=${${(%):-$_P9K_RPROMPT%$_P9K_M(l./$_P9K_M;$_P9K_Y./$_P9K_X;$_P9K_M)}##*/}}'
    _P9K_ALIGNED_RPROMPT+='${_P9K_X::=${_P9K_XY%;*}}'
    _P9K_ALIGNED_RPROMPT+='${_P9K_Y::=${_P9K_XY#*;}}'
  done
  _P9K_ALIGNED_RPROMPT+='${_P9K_X::=$((_P9K_X+2+_P9K_IND))}'
  _P9K_ALIGNED_RPROMPT+='${_P9K_Y::=$((_P9K_X+31))}}+}'

  repeat 32; do
    _P9K_ALIGNED_RPROMPT+='%-$_P9K_Y(l.                                .)'
  done
  repeat 32; do
    _P9K_ALIGNED_RPROMPT+='%-$_P9K_X(l. .)'
  done
  _P9K_ALIGNED_RPROMPT+=' $_P9K_RPROMPT'
  _P9K_ALIGNED_RPROMPT+='$_P9K_T[$((3+!_P9K_IND))]'

  _P9K_LEFT_PREFIX+='${${_P9K_IND::=${${ZLE_RPROMPT_INDENT:-1}/#-*/0}}+}'

  if [[ $POWERLEVEL9K_PROMPT_ADD_NEWLINE == true ]]; then
    repeat ${POWERLEVEL9K_PROMPT_ADD_NEWLINE_COUNT:-1} _P9K_LEFT_PREFIX+=$'\n'
  fi

  if [[ $POWERLEVEL9K_SHOW_RULER == true ]]; then
    _p9k_get_icon RULER_CHAR
    local ruler_char=$_P9K_RETVAL
    _p9k_prompt_length $ruler_char
    if (( _P9K_RETVAL == 1 && $#ruler_char == 1 )); then
      _p9k_color "" prompt_ruler BACKGROUND
      _p9k_background $_P9K_RETVAL
      _P9K_LEFT_PREFIX+=$_P9K_RETVAL
      _p9k_color "" prompt_ruler FOREGROUND
      _p9k_foreground $_P9K_RETVAL
      _P9K_LEFT_PREFIX+=$_P9K_RETVAL
      [[ $ruler_char == '.' ]] && local sep=',' || local sep='.'
      local ruler_len='${$((COLUMNS-_P9K_IND))/#-*/0}'
      _P9K_LEFT_PREFIX+="%b\${(pl$sep$ruler_len$sep$sep${(q)ruler_char}$sep)}%k%f"
      _P9K_LEFT_PREFIX+='$_P9K_T[$((3+!_P9K_IND))]'
    else
      print -P "%F{red}WARNING!%f %BPOWERLEVEL9K_RULER_CHAR%b is not one character long. Ruler won't be rendered."
      print -P "Either change the value of %BPOWERLEVEL9K_RULER_CHAR%b or set %BPOWERLEVEL9K_SHOW_RULER=false%b to"
      print -P "disable ruler."
    fi
  fi

  if [[ $ITERM_SHELL_INTEGRATION_INSTALLED == Yes ]]; then
    _P9K_LEFT_PREFIX+="%{$(iterm2_prompt_mark)%}"
  fi

  _P9K_LEFT_PREFIX+='${${_P9K_BG::=NONE}+}${${_P9K_I::=0}+}'
  _P9K_RIGHT_PREFIX+='${${_P9K_BG::=NONE}+}${${_P9K_I::=0}+}'

  _p9k_get_icon LEFT_SEGMENT_SEPARATOR
  _P9K_T=("%f$_P9K_RETVAL" "" $'\n')
  _p9k_prompt_overflow_bug && _P9K_T+='%{%G%}' || _P9K_T+=''

  _P9K_RIGHT_SUFFIX+='%f%b%k'
  _P9K_RIGHT_PREFIX+='%f%b%k'

  if [[ $POWERLEVEL9K_PROMPT_ON_NEWLINE == true ]]; then
    _p9k_get_icon MULTILINE_FIRST_PROMPT_PREFIX
    _P9K_LEFT_PREFIX+="$_P9K_RETVAL%f%b%k"
    _p9k_get_icon MULTILINE_LAST_PROMPT_PREFIX
    _P9K_LEFT_SUFFIX+=$'\n'$_P9K_RETVAL
    if [[ $POWERLEVEL9K_RPROMPT_ON_NEWLINE != true ]]; then
      if is-at-least 5.3; then
        function _p9k_zle_line_finish() {
          [[ -o TRANSIENT_RPROMPT ]] || return
          _P9K_RPROMPT_OVERRIDE=
          zle && zle .reset-prompt && zle -R
        }
        autoload -Uz add-zle-hook-widget
        zle -N _p9k_zle_line_finish
        add-zle-hook-widget line-finish _p9k_zle_line_finish
        add-zle-hook-widget -D line-finish user:_zsh_highlight_widget_orig-\*
        add-zle-hook-widget -D line-finish user:_zsh_autosuggest_bound_\*
      fi
    fi
  else
    _P9K_LEFT_PREFIX+="%f%b%k"
  fi

  # If the terminal `LANG` is set to `C`, this theme will not work at all.
  if [[ $LANG == "C" && $POWERLEVEL9K_IGNORE_TERM_LANG == false ]]; then
    print -P "\t%F{red}WARNING!%f Your terminal's 'LANG' is set to 'C', which breaks this theme!"
    print -P "\t%F{red}WARNING!%f Please set your 'LANG' to a UTF-8 language, like 'en_US.UTF-8'"
    print -P "\t%F{red}WARNING!%f _before_ loading this theme in your \~\.zshrc. Putting"
    print -P "\t%F{red}WARNING!%f %F{blue}export LANG=\"en_US.UTF-8\"%f at the top of your \~\/.zshrc is sufficient."
    print -P 'Set POWERLEVEL9K_IGNORE_TERM_LANG=true to suppress this warning.'
  fi

  # Display a warning if the terminal does not support 256 colors.
  if [[ $POWERLEVEL9K_IGNORE_TERM_COLORS == false ]]; then
    if zmodload zsh/terminfo 2>/dev/null && (( $+terminfo[colors] && $terminfo[colors] < 256 )); then
      print -P '%F{red}WARNING!%f Your terminal appears to support fewer than 256 colors!'
      print -P 'If your terminal supports 256 colors, please export the appropriate environment variable.'
      print -P 'In most terminal emulators, adding %F{blue}export TERM=xterm-256color%f to your %F{yellow}~/.zshrc%f is sufficient.'
      print -P 'Set %F{blue}POWERLEVEL9K_IGNORE_TERM_COLORS=true%f to suppress this warning.'
    fi
  fi

  if segment_in_use longstatus; then
    print -P '%F{yellow}WARNING!%f The "longstatus" segment is deprecated. Use "%F{blue}status%f" instead.'
    print -P 'For more informations, have a look at https://github.com/bhilburn/powerlevel9k/blob/master/CHANGELOG.md.'
  fi

  if segment_in_use vcs; then
    powerlevel9k_vcs_init
    if [[ $POWERLEVEL9K_DISABLE_GITSTATUS != true ]] && (( ${POWERLEVEL9K_VCS_BACKENDS[(I)git]} )); then
      source ${POWERLEVEL9K_GITSTATUS_DIR:-${_p9k_installation_dir}/gitstatus}/gitstatus.plugin.zsh
      gitstatus_start                                                                 \
        -s ${POWERLEVEL9K_VCS_MAX_NUM_STAGED:-$POWERLEVEL9K_VCS_STAGED_MAX_NUM}       \
        -u ${POWERLEVEL9K_VCS_MAX_NUM_UNSTAGED:-$POWERLEVEL9K_VCS_UNSTAGED_MAX_NUM}   \
        -d ${POWERLEVEL9K_VCS_MAX_NUM_UNTRACKED:-$POWERLEVEL9K_VCS_UNTRACKED_MAX_NUM} \
        -m $POWERLEVEL9K_VCS_MAX_INDEX_SIZE_DIRTY                                     \
        POWERLEVEL9K
    fi
  fi

  if segment_in_use vi_mode && (( $+POWERLEVEL9K_VI_VISUAL_MODE_STRING )); then
    if is-at-least 5.3; then
      function _p9k_zle_line_pre_redraw() {
        [[ $KEYMAP == vicmd ]] &&
          [[ ${REGION_ACTIVE:-0} != $_P9K_REGION_ACTIVE ]] &&
          _P9K_REGION_ACTIVE=${REGION_ACTIVE:-0} &&
          zle && zle .reset-prompt && zle -R
      }
      autoload -Uz add-zle-hook-widget
      add-zle-hook-widget line-pre-redraw _p9k_zle_line_pre_redraw
      add-zle-hook-widget -D line-pre-redraw user:_zsh_highlight_widget_orig-\*
      add-zle-hook-widget -D line-pre-redraw user:_zsh_autosuggest_bound_\*
      _p9k_g_expand POWERLEVEL9K_VI_VISUAL_MODE_STRING
    else
      >&2 print -P '%F{yellow}WARNING!%f POWERLEVEL9K_VI_VISUAL_MODE_STRING requires ZSH >= 5.3.'
      >&2 print -r "Your zsh version is $ZSH_VERSION. Either upgrade zsh or unset POWERLEVEL9K_VI_VISUAL_MODE_STRING."
    fi
  fi

  if segment_in_use dir &&
     [[ $POWERLEVEL9K_SHORTEN_STRATEGY == truncate_with_package_name && $+commands[jq] == 0 ]]; then
    >&2 print -P '%F{yellow}WARNING!%f %BPOWERLEVEL9K_SHORTEN_STRATEGY=truncate_with_package_name%b requires %F{green}jq%f.'
    >&2 print -P 'Either install %F{green}jq%f or change the value of %BPOWERLEVEL9K_SHORTEN_STRATEGY%b.'
  fi

  zle -N zle-keymap-select _p9k_zle_keymap_select

  _P9K_INITIALIZED=1
}

powerlevel9k_refresh_prompt_inplace() {
  emulate -L zsh

  _p9k_init

  _P9K_REFRESH_REASON=precmd
  _p9k_set_prompt
  _P9K_REFRESH_REASON=''
}

powerlevel9k_prepare_prompts() {
  _P9K_EXIT_CODE=$?
  _P9K_PIPE_EXIT_CODES=( "$pipestatus[@]" )
  _P9K_COMMAND_DURATION=$((EPOCHREALTIME - _P9K_TIMER_START))
  _P9K_TIMER_START=1e10
  _P9K_REGION_ACTIVE=0

  unsetopt localoptions
  prompt_opts=(cr percent sp subst)
  setopt nopromptbang prompt{cr,percent,sp,subst}

  powerlevel9k_refresh_prompt_inplace
}

powerlevel9k_preexec() {
  _P9K_TIMER_START=$EPOCHREALTIME
}

prompt_mattnew_setup() {
  prompt_powerlevel9k_teardown

  add-zsh-hook precmd powerlevel9k_prepare_prompts
  add-zsh-hook preexec powerlevel9k_preexec

  _P9K_TIMER_START=1e10
  _P9K_ENABLED=1
}

prompt_powerlevel9k_teardown() {
  add-zsh-hook -D precmd powerlevel9k_\*
  add-zsh-hook -D preexec powerlevel9k_\*
  PROMPT='%m%# '
  RPROMPT=
  _P9K_ENABLED=0
}

autoload -U colors && colors
autoload -Uz add-zsh-hook

zmodload zsh/datetime
zmodload zsh/mathfunc
zmodload zsh/system
zmodload -F zsh/stat b:zstat

prompt_mattnew_setup

source "${_p9k_installation_dir}/lib/purepower"
