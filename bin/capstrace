#! /bin/bash

readonly ARGS="$*"
readonly ARGA=("$@")

readonly TMP_EXT=".nexcess.bak"
readonly OUTPUT_DIR="${HOME}/nex_strace"
readonly PIPE_NAME="/tmp/nexcess_strace_pipe"
readonly DEFAULT_IP="192.240.191.2"

alias cat='/bin/cat'
alias chmod='/bin/chmod --preserve-root'
alias chown='/bin/chown --preserve-root'
alias dd='/bin/dd'
alias find='/bin/find'
alias grep='/bin/grep'
alias mkdir='/bin/mkdir'
alias mkfifo='/usr/bin/mkfifo'
alias mv='/bin/mv'
alias rm='/bin/rm --preserve-root'
alias sleep='/bin/sleep'
alias strace='/usr/bin/strace'

# Print usage
_usage() {
  cat <<- EOF

  Captures strace and php GLOBALS variable information of one or matching
  requests to a website. Outputs data to "$OUTPUT_DIR".

  Usage:

  capstrace [options]

  -h|--help                        Prints this message.

  -f|--file FILE                   Target file for catching process.
                                   Usually an index.php, but not always.

  -i|--ip-address REMOTE_ADDR,all  IP address initiating process.
                                   Default value is Nexcess IP: 192.240.191.2
                                   Special value of 'all' will match any IP.

  -u|--uri REQUEST_URI             Specific URI to monitor for.

  -q|--query-string QUERY_STRING   Specific query string to monitor for.

  -p|--persist                     Default behavior is to catch one request. This
                                   flag enables capstrace to catch every matching
                                   request until you exit capstrace.

EOF
}

# Convert long command line options into short ones for getopts
_cmdline() {

  local x;

  for x in ${ARGA[*]}; do

    local args

    case "$x" in
      "--help"|"-h")
        args="${args}-h "
        ;;
      "--file"|"-f")
        args="${args}-f "
        ;;
      "--ip-address"|"-i")
        args="${args}-i "
        ;;
      "--query-string"|"-q")
        args="${args}-q "
        ;;
      "--uri"|"-u")
        args="${args}-u "
        ;;
      "--persist"|"-p")
        args="${args}-p "
        ;;
      *)
        args="${args}${x} ";
        ;;
    esac

  done


  echo "$args";
}

# Insert code into target file
_addCode () {

  local file address addressstring uri uristring query querystring;

  file="$1";
  address="$2";
  uri="$3";
  query="$4"

  mv "$file"{,"$TMP_EXT"} || return 1;

  cp -a "$file""$TMP_EXT" "$file";

  if [[ "$uri" == "NULL" ]]; then
    uristring="";
  else
    uristring=" and (strlen(strstr(\$_SERVER[\"REQUEST_URI\"],\"$uri\"))>0)";
  fi

  if [[ "$query" == "NULL" ]]; then
    querystring="";
  else
    querystring=" and (strlen(strstr(\$_SERVER[\"QUERY_STRING\"],\"$query\"))>0)";
  fi

  if [[ "$address" == "all" ]]; then
    addressstring="1";
  else
    addressstring="\$_SERVER[\"REMOTE_ADDR\"] == \"$address\" || (strlen(strstr(\$_SERVER[\"HTTP_X_FORWARDED_FOR\"],\"$address\"))>0)";
  fi

  cat << EOF > "$file"
<?php
  if((@($addressstring)$uristring)$querystring){

    file_put_contents("$PIPE_NAME",getmypid() . "\n");
    usleep(100000);
    file_put_contents("/tmp/" . date('Y-m-d-H:i:s') . "-" . getmypid() . "-GLOBALS", print_r(\$GLOBALS,true) . "\\n\\n" . file_get_contents("php://input"));
  }
?>
EOF

  cat "$file""$TMP_EXT" >> "$file";

}

# Perform strace of request
_strace () {

  local output pid str_pid

  pid="$1";

  output="${OUTPUT_DIR}/$(date "+%F-%T")-$pid-strace";

  strace -fTrvs200000 -o "$output" -p"$pid" &

  str_pid="$!"

  trap 'break' INT QUIT TERM;
  sleep 0.1;

  # Kill strace once php process becomes idle
  if [[ -e /proc/"$str_pid" ]]; then
    while(true); do
      if tail | grep -qE "^$pid .*(accept\(0|\+\+\+ (killed|exited))"; then
        kill "$str_pid" 2>/dev/null || echo "$pid exited";
        break;
      fi
    done < "$output"
  fi

  kill "$str_pid" 2> /dev/null;

  find /tmp/ -name "*-GLOBALS" -user "$(getusr)" -exec /bin/mv -t "$OUTPUT_DIR" {} + 2>/dev/null

  chmod 600 "${OUTPUT_DIR}"/*
  chown root. "${OUTPUT_DIR}"/*

}

# Monitor for incoming requests
_monitor () {

  local pid persist parent

  persist="$1";

  printf "Waiting for process. Press enter to stop.\n";

  parent="$$";

  # Perform monitoring in background
  (while (true); do

  read -r pid;

  if [[ -n $pid ]]; then
    if [[ -n $persist ]]; then
      _strace "$pid" &
    else
      _strace "$pid";
      kill -s INT "$parent" 2>/dev/null;
      return;
    fi
  fi

  done <"$PIPE_NAME"; ) &

  # Handle user exiting capstrace
  trap 'return' INT QUIT TERM;

  read -r;

  return;
}

main () {

  local file address uri query persist;

  # Parse command line options
  while getopts "hf:i:u:q:p" OPTION $(_cmdline); do

    case $OPTION in
      h)
        _usage;
        exit 0;
        ;;
      f)
        file="$OPTARG";
        ;;
      i)
        address="$OPTARG";
        ;;
      u)
        uri="$OPTARG";
        ;;
      q)
        query="$OPTARG";
        ;;
      p)
        persist="yes";
        ;;
    esac

  done

  # Set defaults where necessary
  if [[ -z "$file" ]]; then
    if [[ -r "${ARGA[0]}" ]]; then
      file="${ARGA[0]}";
    else
      _usage;
      return;
    fi
  fi

  if [[ -L "$file" ]]; then
    echo "$file is a symbolic link";
    exit;
  fi

  if [[ -z "$address" ]]; then
    address="$DEFAULT_IP";
  fi

  if [[ -z "$uri" ]]; then
    uri="NULL";
  fi

  if [[ -z "$query" ]]; then
    query="NULL";
  fi

  [[ -d $OUTPUT_DIR ]] || mkdir "${OUTPUT_DIR}";
  chmod 700 "${OUTPUT_DIR}"

  mkfifo -m 666 "$PIPE_NAME";

  _addCode "$file" "$address" "$uri" "$query" || return 1;

  _monitor "$persist";

  mv -f "$file"{"$TMP_EXT",}

  # Flush pipe to prevent any remaining PHP processes from hanging
  sleep 0.1;
  dd if="$PIPE_NAME" iflag=nonblock of=/dev/null &> /dev/null

  rm -f "$PIPE_NAME";
  pkill -P $$ 2> /dev/null;

}

main;
