#! /bin/bash

readonly ARGS="$*"
readonly ARGA=("$@")

readonly TMP_EXT=".nexcess.bak"
readonly OUTPUT_DIR="${HOME}/nex_strace"
readonly PIPE_PREFIX="/tmp/nexcess_strace_pipe-"
readonly DEFAULT_IP="192.240.191.2"

alias cat='/bin/cat'
alias chmod='/bin/chmod --preserve-root'
alias chown='/bin/chown --preserve-root'
alias dd='/bin/dd'
alias find='/bin/find'
alias grep='/bin/grep'
alias mkdir='/bin/mkdir'
alias mkfifo='/usr/bin/mkfifo'
alias mv='/bin/mv'
alias rm='/bin/rm --preserve-root'
alias sleep='/bin/sleep'
alias strace='/usr/bin/strace'

monitor_pid=""

# Print usage
_usage() {
  cat <<- EOF

  Captures strace and php GLOBALS variable information of one or matching
  requests to a website. Outputs data to "$OUTPUT_DIR". Can also be run on each
  node of a cluster without conflict.

  Usage:

  capstrace [options]

  -h|--help                        Prints this message.

  -f|--file FILE                   Target file for catching process.
                                   Usually an index.php, but not always.
                                   Accepts a comma separated list of files
                                   for capturing processes at multiple entry
                                   points.

  -i|--ip-address REMOTE_ADDR,all  IP address initiating process.
                                   Default value is Nexcess IP: 192.240.191.2
                                   Special value of 'all' will match any IP.

  -u|--uri REQUEST_URI             Specific URI to monitor for.

  -q|--query-string QUERY_STRING   Specific query string to monitor for.

EOF
}

# Convert long command line options into short ones for getopts
_cmdline() {

  local x;

  for x in ${ARGA[*]}; do

    local args

    case "$x" in
      "--help"|"-h")
        args="${args}-h "
        ;;
      "--file"|"-f")
        args="${args}-f "
        ;;
      "--ip-address"|"-i")
        args="${args}-i "
        ;;
      "--query-string"|"-q")
        args="${args}-q "
        ;;
      "--uri"|"-u")
        args="${args}-u "
        ;;
      "--daemonize"|"-d")
        args="${args}-d "
        ;;
      *)
        args="${args}${x} ";
        ;;
    esac

  done


  echo "$args";
}

# Insert code into target file
_addCode () {

  local file address addressstring uri uristring query querystring;

  file="$1";
  address="$2";
  uri="$3";
  query="$4"

  mv "$file"{,"$TMP_EXT"} || return 1;

  cp -a "$file""$TMP_EXT" "$file";

  if [[ "$uri" == "NULL" ]]; then
    uristring="";
  else
    uristring=" and (strlen(strstr(\$_SERVER[\"REQUEST_URI\"],\"$uri\"))>0)";
  fi

  if [[ "$query" == "NULL" ]]; then
    querystring="";
  else
    querystring=" and (strlen(strstr(\$_SERVER[\"QUERY_STRING\"],\"$query\"))>0)";
  fi

  if [[ "$address" == "all" ]]; then
    addressstring="1";
  else
    addressstring="\$_SERVER[\"REMOTE_ADDR\"] == \"$address\" || (strlen(strstr(\$_SERVER[\"HTTP_X_FORWARDED_FOR\"],\"$address\"))>0)";
  fi

  cat << EOF > "$file"
<?php
  if((@($addressstring)$uristring)$querystring){

    file_put_contents("$PIPE_NAME",getmypid() . "\n");
    usleep(100000);
    file_put_contents("/tmp/" . date('Y-m-d-H:i:s') . "-" . getmypid() . "-GLOBALS", print_r(\$GLOBALS,true) . "\\n\\n" . file_get_contents("php://input"));
  }
?>
EOF

cat "$file""$TMP_EXT" >> "$file";

}

# Perform strace of request
_strace () {

  local output pid str_pid

  pid="$1";

  output="${OUTPUT_DIR}/$(date "+%F-%T")-$pid-strace";

  strace -fTrvs200000 -o "$output" -p"$pid" &

  str_pid="$!"

  trap 'break' INT QUIT TERM;
  sleep 0.1;

  # Kill strace once php process becomes idle
  if [[ -e /proc/"$str_pid" ]]; then
    while(true); do
      if tail | grep -qE "^$pid .*(accept\(0|\+\+\+ (killed|exited))"; then
        kill "$str_pid" 2>/dev/null || echo "$pid exited";
        break;
      fi
    done < "$output"
  fi

  kill "$str_pid" 2> /dev/null;

  find /tmp/ -name "*-GLOBALS" -user "$(getusr)" -exec /bin/mv -t "$OUTPUT_DIR" {} + 2>/dev/null

  chmod 600 "${OUTPUT_DIR}"/*
  chown root. "${OUTPUT_DIR}"/*

}

# Monitor for incoming requests
_monitor () {

  local pid maxRunTime

  maxRunTime="$1";

  # Perform monitoring in background
  (while (true); do

    read -r pid;

    if [[ -n $pid ]]; then
      _strace "$pid" &
    fi

  done <"$PIPE_NAME";) &


  monitor_pid="$!"

  trap 'return' INT QUIT TERM;

  if [[ $maxRunTime ]]; then

    start_time="$(date "+%s")"

    while [[ -e /proc/"$monitor_pid" ]]; do

      current_time="$(date "+%s")"

      if (( current_time > (start_time + maxRunTime) )) ; then
        return;
      fi

      sleep 5;

    done
  else

    # Handle user exiting capstrace

    printf "Waiting for process. Press enter to stop.\n";

    read -r;

  fi
}

main () {

  local files filesUsed address uri query;

  # Parse command line options
  while getopts "hf:i:u:q:d:" OPTION $(_cmdline); do

    case $OPTION in
      h)
        _usage;
        exit 0;
        ;;
      f)
        files=($(echo "$OPTARG" | tr ',' ' ' ));
        ;;
      i)
        address="$OPTARG";
        ;;
      u)
        uri="$OPTARG";
        ;;
      q)
        query="$OPTARG";
        ;;
      d)
        maxRunTime="$(( $(echo "$OPTARG" | grep -Po '\d*') * 60 ))";
        ;;
      *);;
    esac

  done

  # Set defaults where necessary
  if [[ -z "${files[0]}" ]]; then
    if [[ -r "${ARGA[0]}" ]]; then
      files=("${ARGA[0]}");
    else
      _usage;
      return;
    fi
  fi

  if [[ -z "$address" ]]; then
    address="$DEFAULT_IP";
  fi

  if [[ -z "$uri" ]]; then
    uri="NULL";
  fi

  if [[ -z "$query" ]]; then
    query="NULL";
  fi

  [[ -d $OUTPUT_DIR ]] || mkdir "${OUTPUT_DIR}";
  chmod 700 "${OUTPUT_DIR}"

  PIPE_NAME=$(grep -Po "${PIPE_PREFIX}[^\"]*" "${files[0]}") \
    || PIPE_NAME="${PIPE_PREFIX}$(uuidgen)"

  # Add the needed code to any files that don't currently have it
  for x in ${files[*]}; do

    if [[ -L "$x" ]]; then
      echo "$x is a symbolic link";
      continue;
    fi

    if ! grep -Fq "${PIPE_NAME}" "$x"; then
      _addCode "$x" "$address" "$uri" "$query" \
        && filesUsed+=("$x");
    fi

  done

  # Create pipe if not already present
  if [[ ! -e "$PIPE_NAME" ]]; then
    mkfifo -m 666 "$PIPE_NAME";
    remove_pipe="yes";
  fi

  _monitor "$maxRunTime";

  # Clean up the stuff we touched
  for x in ${filesUsed[*]}; do

    if [[ ! -L "$x" && -e "${x}${TMP_EXT}" ]]; then
      mv -f "$x"{"$TMP_EXT",}
    fi

  done

  # Flush pipe to prevent any remaining PHP processes from hanging
  if [[ "$remove_pipe" == "yes" ]]; then
    sleep 0.1;
    dd if="$PIPE_NAME" iflag=nonblock of=/dev/null &> /dev/null
    rm -f "$PIPE_NAME";
  fi

  kill "$monitor_pid"

}

if echo "$ARGS" | grep -Pq '\s*(-d|--daemonize) \d*'; then
  main &
else
  main;
fi
