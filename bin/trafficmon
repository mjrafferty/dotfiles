#! /usr/bin/env bash

# Script Arguments
readonly ARGA=("$@")

# Configurable Variables
readonly OUTPUT_FILE="${HOME}/trafficmon.log"
readonly IPTABLES_PREFIX="Outbound Connection: "

# Necessary Global Variables
DESTINATION_IP=""

# Print usage
_usage () {
  cat <<- EOF

  Captures outbound traffic to a given IP address. Pulls data on which process
  is running the outbound traffic. Outputs data to "$OUTPUT_FILE".

  Usage:

  trafficmon [options] <ip address>

  -d|--daemonize [hours]    Runs process as a daemon for specified length of
                            time in hours.

  -k|--kill                 Kills daemonized trafficmon instance.

  -h|--help                 Prints this message.
  
EOF
}

# Convert long command line options into short ones for getopts
_cmdline () {
  local x;

  for x in "${ARGA[@]}"; do
    local args

    case "$x" in
      "--help"|"-h")
        args="${args}-h "
        ;;
      "--ip-address"|"-i")
        args="${args}-i "
        ;;
      "--daemonize"|"-d")
        args="${args}-d "
        ;;
      "--kill"|"-k")
        args="${args}-k "
        ;;
      "--"*)
        echo "$x is not a supported option." >&2
        ;;
      *)
        args="${args}${x} ";
        ;;
    esac
  done

  echo "$args";
}

_checkIpTables () {
  if iptables-save -t filter | grep -q "${DESTINATION_IP}.*${IPTABLES_PREFIX}"; then
    return
  else
    return 1
  fi
}

_addRule () {
  local -a rule_options

  rule_options=(
    --insert OUTPUT
    --destination "${DESTINATION_IP}"
    --protocol tcp
    --match state
    --state NEW
    --match limit
    --limit 6/m
    --limit-burst 1
    --jump LOG
    --log-uid
    --log-prefix "${IPTABLES_PREFIX}"
    --log-level alert
    )

  iptables "${rule_options[@]}"
}

_removeRule () {
  local -a rule_options

  rule_options=(
    --delete OUTPUT
    --destination "${DESTINATION_IP}"
    --protocol tcp
    --match state
    --state NEW
    --match limit
    --limit 6/m
    --limit-burst 1
    --jump LOG
    --log-uid
    --log-prefix "${IPTABLES_PREFIX}"
    --log-level alert
    )

  iptables "${rule_options[@]}"
}

_capture () {
  local port pid;

  port="$1";

  {
    netstat -tnap \
      | grep --line-buffered -Po "^(\S+\s+){3}\S+:${port}.*\s+\K\d+(?=/\w+)"  \
      | while read -r pid; do
          date "+%F-%T";
          printf "\nPS:\n"
          ps -lf -p "$pid"
          printf "\nLSOF:\n "
          lsof -Pn -p "$pid"
          printf "\n\n"
        done
    echo;
  } >> "$OUTPUT_FILE"
}

_monitor () {
  local ip port
  
  trap "_cleanUp" EXIT

  journalctl --dmesg --follow --lines=0 --priority=alert --output=cat 2> /dev/null \
    | grep --line-buffered -Po "^${IPTABLES_PREFIX}.*DST=${ip}.*PROTO=\w+ SPT=\K\d+" \
    | while read -r port;  do
      _capture "$port";
    done
}

# Monitor for incoming requests
_run () {
  local monitor_pid daemon_time start_time current_time
  daemon_time="$1"

  # Perform monitoring in background
  _monitor &> /dev/null &
  monitor_pid="$!"

  printf -v start_time '%(%s)T\n' '-1'
  
  trap "_cleanUp" EXIT

  while [[ -e /proc/"$monitor_pid" ]]; do
    if ! _checkIpTables; then
      _addRule
    fi
    sleep 10;
    if [[ -n "${daemon_time}" ]]; then
      printf -v current_time '%(%s)T\n' '-1'
      if ((current_time - start_time > daemon_time)); then
        break
      fi
    fi
  done

  _cleanUp
}

# Clean up any changes made
_cleanUp () {
  local pgid

  _removeRule 2> /dev/null

  pgid="$(ps --no-headers -o pgid "$BASHPID")"
  if [[ -n "${pgid}" ]]; then
    pkill -g "${pgid/ /}" &> /dev/null;
  fi
}

_kill() {
  local pids pgids pgid
  mapfile -t pids < <(pgrep -P 1 -f trafficmon)

  if [[ -z "${pids[0]}" ]]; then
    echo "No processes found."
    return
  fi

  mapfile -t pgids < <(ps --no-headers -o pgid "${pids[@]}")

  for pgid in "${pgids[@]}"; do
    pkill -g "${pgid/ /}" &> /dev/null;
  done
}

# Main
main () {
  local option cmdline daemon_time

  mapfile -t cmdline < <(_cmdline | tr ' ' '\n');

  while getopts ":hd:ki:" option "${cmdline[@]}"; do
    case $option in
      h)
        _usage;
        exit 0;
        ;;
      d)
        if [[ "$OPTARG" == [0-9]* ]]; then
          daemon_time="$(( $(echo "$OPTARG" | grep -Po '\d*') * 3600 ))";
        else
          echo "Invalid daemon time.";
          exit 1;
        fi
        ;;
      k)
        _kill;
        exit
        ;;
      "?")
        echo "-${OPTARG} is not a supported option." >&2
        ;;
      *);;
    esac
  done

  DESTINATION_IP="${ARGA[$((OPTIND - 1))]}"

  if [[ -z "${DESTINATION_IP}" ]]; then
    echo "Destination IP address is required" >&2
    exit 2
  fi

  if [[ -z "${daemon_time}" ]]; then
    printf "Tracking outbound requests to %s\n" "${DESTINATION_IP}"
    printf "Log file: %s\n" "$OUTPUT_FILE"
    _run
  else
    _run "${daemon_time}" &> /dev/null &
    main_pid="$!"
    printf "\ntrafficmon is now running. Run with -k to end.\n\n"
    printf "Tracking outbound requests to %s\n" "${DESTINATION_IP}"
    printf "Main PID: %s\n" "${main_pid}"
    printf "Log file: %s\n" "$OUTPUT_FILE"
  fi
}

main
