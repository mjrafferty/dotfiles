#! /bin/bash

# Script Arguments
readonly ARGS="$*"
readonly ARGA=("$@")

# Alias executables to prevent PATH issues
readonly CAT='/bin/cat'
readonly CHOWN='/bin/chmod'
readonly DATE='/bin/date'
readonly DD='/bin/dd'
readonly FIND='/bin/find'
readonly GREP='/bin/grep'
readonly MKDIR='/bin/mkdir'
readonly MKFIFO='/usr/bin/mkfifo'
readonly MV='/bin/mv'
readonly PKILL='/usr/bin/pkill'
readonly RM='/bin/rm'
readonly SLEEP='/bin/sleep'
readonly STRACE='/usr/bin/strace'
readonly TAIL='/usr/bin/tail'
readonly TR='/usr/bin/tr'

# Configurable Variables
readonly TMP_EXT=".nexcess.bak"
readonly OUTPUT_DIR="/home/$(pwd | "$GREP" -Po "home/\K[^/]*")/nex_strace"
readonly TEMP_DIR="${OUTPUT_DIR}"
readonly PIPE_PREFIX="${TEMP_DIR}/nexcess_strace_pipe-"
readonly DEFAULT_IP="${MY_IP:-192.240.191.2}"

if [[ -e /usr/bin/pigz ]]; then
  readonly GZIP='/usr/bin/pigz';
else
  readonly GZIP='/bin/gzip';
fi

# Necessary Global Variables
MONITOR_PID=""
PIPE_NAME=""
REMOVE_PIPE=""
FILES=()
FILES_USED=()


# Print usage
_usage() {
  "$CAT" <<- EOF

  Captures "$STRACE" and php GLOBALS variable information of one or matching
  requests to a website. Outputs data to "$OUTPUT_DIR". Can also be run on each
  node of a cluster without conflict.

  Usage:

  capstrace [options]

  -h|--help                        Prints this message.

  -f|--file FILE                   Target file for catching process.
                                   Usually an index.php, but not always.
                                   Accepts a comma separated list of files
                                   for capturing processes at multiple entry
                                   points.

  -i|--ip-address REMOTE_ADDR,all  IP address initiating process.
                                   Default value is Nexcess IP: 192.240.191.2
                                   or the value of \$MY_IP if it is set in your
                                   environment. Special value of 'all' will
                                   match any IP.

  -u|--uri REQUEST_URI             Specific URI to monitor for.

  -q|--query-string QUERY_STRING   Specific query string to monitor for.

  -d|--daemonize  HOURS_TO_RUN     Runs program as a daemon for the number of
                                   hours specified.

  -k|--kill                        Manually kill daemonized capstrace instance.

EOF
}

# Convert long command line options into short ones for getopts
_cmdline() {

  local x;

  for x in ${ARGA[*]}; do

    local args

    case "$x" in
      "--help"|"-h")
        args="${args}-h "
        ;;
      "--file"|"-f")
        args="${args}-f "
        ;;
      "--ip-address"|"-i")
        args="${args}-i "
        ;;
      "--query-string"|"-q")
        args="${args}-q "
        ;;
      "--uri"|"-u")
        args="${args}-u "
        ;;
      "--daemonize"|"-d")
        args="${args}-d "
        ;;
      "--kill"|"-k")
        args="${args}-k "
        ;;
      *)
        args="${args}${x} ";
        ;;
    esac

  done

  echo "$args";

}

# Insert code into target file
_addCode () {

  local file address address_string uri uri_string query query_string;

  file="$1";
  address="$2";
  uri="$3";
  query="$4"

  "$MV" "$file"{,"$TMP_EXT"} || return 1;

  cp -a "$file""$TMP_EXT" "$file";

  if [[ "$uri" == "NULL" ]]; then
    uri_string="";
  else
    uri_string=" and (strlen(strstr(\$_SERVER[\"REQUEST_URI\"],\"$uri\"))>0)";
  fi

  if [[ "$query" == "NULL" ]]; then
    query_string="";
  else
    query_string=" and (strlen(strstr(\$_SERVER[\"QUERY_STRING\"],\"$query\"))>0)";
  fi

  if [[ "$address" == "all" ]]; then
    address_string="1";
  else
    address_string="\$_SERVER[\"REMOTE_ADDR\"] == \"$address\" || (strlen(strstr(\$_SERVER[\"HTTP_X_FORWARDED_FOR\"],\"$address\"))>0)";
  fi

  "$CAT" << EOF > "$file"
<?php
  if((@($address_string)$uri_string)$query_string){

    file_put_contents("$PIPE_NAME",getmypid() . "\n");
    usleep(100000);
    file_put_contents("$TEMP_DIR/" . date('Y-m-d-H:i:s') . "-" . getmypid() . "-GLOBALS", print_r(\$GLOBALS,true) . "\\n\\n" . file_get_contents("php://input"));
  }
?>
EOF

"$CAT" "$file""$TMP_EXT" >> "$file";

}

# Perform "$STRACE" of request
_strace () {

  local output pid str_pid daemon_time

  pid="$1";
  daemon_time="$2";

  output="${OUTPUT_DIR}/$("$DATE" "+%F-%T")-$pid-strace";

  sudo "$STRACE" -fTrvs200000 -o "$output" -p"$pid" &

  str_pid="$!"

  trap 'break' INT QUIT TERM;
  "$SLEEP" 0.1;

  # Kill "$STRACE" once php process becomes idle
  while [[ -e /proc/"$str_pid" ]]; do

    if "$TAIL" | "$GREP" -qE "^$pid .*(accept\(0|\+\+\+ (killed|exited))"; then

      sudo kill "$str_pid" 2>/dev/null || echo "$pid exited";
      break;

    fi

  done < "$output"

  sudo kill "$str_pid" 2> /dev/null;

  "$FIND" "${TEMP_DIR}/" -name "*-GLOBALS" -user "$(pwd | "$GREP" -Po "home/\K[^/]*")" -exec /bin/mv -t "$OUTPUT_DIR" {} + 2>/dev/null

  if [[ "$daemon_time" ]]; then
    "$GZIP" "$output";
  fi

  "$CHMOD" 600 "${OUTPUT_DIR}"/*

}

# Monitor for incoming requests
_monitor () {

  local pid daemon_time start_time current_time

  daemon_time="$1";

  # Perform monitoring in background
  (while (true); do

    read -r pid;

    if [[ -n $pid ]]; then
      _strace "$pid" "$daemon_time" &
    fi

  done <"$PIPE_NAME";) &


  MONITOR_PID="$!"

  trap 'return' INT QUIT TERM;

  if [[ $daemon_time ]]; then

    start_time="$("$DATE" "+%s")"

    while [[ -e /proc/"$MONITOR_PID" ]]; do

      current_time="$("$DATE" "+%s")"

      if (( current_time > (start_time + daemon_time) )) ; then
        return;
      fi

      "$SLEEP" 5;

    done
  else

    # Handle user exiting capstrace

    printf "Waiting for process. Press enter to stop.\n";

    read -r;

  fi

}

# Perform setup tasks
_setup() {

  local x address uri query

  address="$1"
  uri="$2"
  query="$3"

  # Create output directory if necessary and restrict perms
  [[ -d $OUTPUT_DIR ]] || "$MKDIR" "${OUTPUT_DIR}";
  "$CHMOD" 700 "${OUTPUT_DIR}"

  # Add the needed code to any files that don't currently have it
  for x in ${FILES[*]}; do

    if [[ -L "$x" ]]; then
      echo "$x is a symbolic link";
      continue;
    fi

    if ! "$GREP" -Fq "${PIPE_NAME}" "$x"; then
      _addCode "$x" "${address}" "${uri}" "${query}" \
        && FILES_USED+=("$x");
    fi

  done

  # Create pipe if not already present
  if [[ ! -e "$PIPE_NAME" ]]; then
    "$MKFIFO" -m 666 "$PIPE_NAME";
    REMOVE_PIPE="yes";
  fi

}

# Clean up any changes made
_cleanUp() {

  local x
  # Clean up the stuff we touched
  for x in ${FILES_USED[*]}; do

    if [[ ! -L "$x" && -e "${x}${TMP_EXT}" ]]; then
      "$MV" -f "$x"{"$TMP_EXT",}
    fi

  done

  # Flush pipe to prevent any remaining PHP processes from hanging
  if [[ "$REMOVE_PIPE" == "yes" ]]; then
    "$SLEEP" 0.1;
    "$DD" if="$PIPE_NAME" iflag=nonblock of=/dev/null &> /dev/null
    "$RM" -f "$PIPE_NAME";
  fi

  sudo kill "$MONITOR_PID" 2> /dev/null

}

# Main
main () {

  local address uri query daemon_time x;

  # Parse command line options
  while getopts "hf:i:u:q:d:k" OPTION $(_cmdline); do

    case $OPTION in
      h)
        _usage;
        exit 0;
        ;;
      f)
        mapfile -t FILES < <(echo "$OPTARG" | "$TR" ',' '\n' );

        for x in ${FILES[*]}; do

          if [[ ! -e "$x" ]]; then

            echo "$x is not a valid filename";
            return 1;

          fi
        done
        ;;
      i)
        address="$OPTARG";
        ;;
      u)
        uri="$OPTARG";
        ;;
      q)
        query="$OPTARG";
        ;;
      d)
        daemon_time="$(( $(echo "$OPTARG" | "$GREP" -Po '\d*') * 3600 ))";
        ;;
      k)
        "$PKILL" capstrace -P 1
        exit;
        ;;
      *);;
    esac

  done

  # Set defaults where necessary
  if [[ -z "${FILES[0]}" ]]; then
    if [[ -e "${ARGA[0]}" ]]; then
      FILES=("${ARGA[0]}");
    else
      _usage;
      return 1;
    fi
  fi

  # Check if we already have a pipe id in the file ( Mainly for clusters )
  PIPE_NAME=$("$GREP" -Po "${PIPE_PREFIX}[^\"]*" "${FILES[0]}") \
    || PIPE_NAME="${PIPE_PREFIX}$(uuidgen)"

  trap "_cleanUp" EXIT;

  _setup "${address:=$DEFAULT_IP}" "${uri:=NULL}" "${query:=NULL}";

  _monitor "$daemon_time";

  _cleanUp;

}

# Background script if run in daemon mode
if echo "$ARGS" | "$GREP" -Pq '\s*(-d|--daemonize) \d*'; then
  main &
else
  main;
fi
