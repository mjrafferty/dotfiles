#! /usr/bin/env bash

USER_AGENT="TTFB test"

readonly ARGA=("$@")

readonly CAT='/bin/cat'
readonly CURL='/usr/bin/curl'

if [[ -n "${XDG_DATA_HOME}" ]]; then
  COOKIE_FILE="${XDG_DATA_HOME}/ttfb.cookies"
else
  COOKIE_FILE="${HOME}/.ttfb.cookies"
fi

WORKING_DIR="$(mktemp -d)"
HEADER_FILE="${WORKING_DIR}/headers"
ERR_FILE="${WORKING_DIR}/error"
OUT_FILE="${WORKING_DIR}/out"

WRITE_OUT="http_code:%{http_code}\ntime_connect:%{time_connect}\ntime_starttransfer:%{time_starttransfer}\ntime_total:%{time_total}\nspeed_download:%{speed_download}\nsize_download:%{size_download}\n"

CURL_OPTS=(
  "--insecure"
  "--location"
  "--silent"
  "--show-error"
  "--compressed"
  "--cookie" "${COOKIE_FILE}"
  "--cookie-jar" "${COOKIE_FILE}"
  "--user-agent" "${USER_AGENT}"
  "--dump-header" "${HEADER_FILE}"
  "--output" "/dev/null"
  "--stderr" "${ERR_FILE}"
  "--write-out" "${WRITE_OUT}" 
)

_usage() {
  "$CAT" <<- EOF

  Usage: ttfb <domain>

  -H|--headers
  -s|--silent
  -v|--verbose
  -n|--number
  -l|--loop
  -a|--average
  -p|--patern

EOF
}

# Convert long command line options into short ones for getopts
_cmdline() {

  local x;

  for x in ${ARGA[*]}; do

    case "$x" in
      "--help"|"-h")
        args="${args}-h "
        ;;
      "--headers"|"-H")
        args="${args}-H "
        ;;
      "--silent"|"-s")
        args="${args}-s "
        ;;
      "--verbose"|"-v")
        args="${args}-v "
        ;;
      "--number"|"-n")
        args="${args}-n "
        ;;
      "--loop"|"-l")
        args="${args}-l "
        ;;
      "--average"|"-a")
        args="${args}-a "
        ;;
      "--pattern"|"-p")
        args="${args}-p "
        ;;
      "--"*)
        echo "$x is not a supported option." >&2
        ;;
      *)
        args="${args}${x} "
        ;;
    esac
  done

  echo "$args";

}

_cleanUp () {
  rm -r "${WORKING_DIR}"
}

main () {

  local cmdline dump_headers silent number stat header;

  number=1;
  header_pattern="+(*)"

  trap "_cleanUp" EXIT;

  mapfile -t cmdline < <(_cmdline | tr ' ' '\n');

  while getopts ":hHsvn:lap:" OPTION "${cmdline[@]}"; do

    case $OPTION in
      h)
        _usage;
        exit 0;
        ;;
      H)
        dump_headers=1;
        ;;
      s)
        silent=1;
        ;;
      v)
        CURL_OPTS+=("--verbose")
        ;;
      n)
        if [[ "${OPTARG}" == [0-9]* ]]; then
          number="${OPTARG}"
        else
          echo "Argument to -n is not a valid number"
          exit 1;
        fi
        ;;
      l)
        number=99999;
        ;;
      a)
        ;;
      p)
        dump_headers=1;

        pattern="${OPTARG//[-_]/}"
        pattern="${pattern,,}"
        header_pattern="+(${pattern//,/|})"
        ;;
      "?")
        echo "-${OPTARG} is not a supported option." >&2
        ;;
      *);;
    esac
  done

  for (( num=1; num<=number; num++ )); do

    ## Do request ##
    "${CURL}" "${CURL_OPTS[@]}" "${ARGA[${#ARGA[@]} - 1]}" > "${OUT_FILE}"
    ## Do request ##


    ## Collect data ##
    declare -A stats;

    while read -r stat; do
      stats[${stat%%:*}]="${stat#*:}"
    done < "${OUT_FILE}"


    declare -A headers;

    {
      # Get rid of first line
      read -r header

      while read -r header; do
        if [[ "${header}" == *":"* ]]; then
          headers[${header%%:*}]="${header#*: }"
        fi
      done

    } < "${HEADER_FILE}"
    ## Collect data ##


    ## Print ##
    echo "--- Request ${num} BEGIN ---";
    if [[ "${silent}" != 1 ]]; then

      echo "HTTP: ${stats[http_code]} Connect: ${stats[time_connect]} TTFB: ${stats[time_starttransfer]} Total time: ${stats[time_total]} Speed: ${stats[speed_download]} b/s Size: ${stats[size_download]} b"

      [[ -s "${ERR_FILE}" ]] && cat "${ERR_FILE}"


    fi

    if [[ -s "${HEADER_FILE}" && "$dump_headers" == 1 ]]; then

      for header in "${!headers[@]}"; do

        normalized_header="${header//[-_]/}"
        normalized_header="${normalized_header,,}"

        if [[ "$normalized_header" == *${header_pattern}* ]]; then
          echo "${header}: ${headers[$header]}"
        fi

      done

    fi

    echo "--- Request ${num} END ---";

    ## Print ##


  done

}

main;
